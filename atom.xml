<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云之学习之路</title>
  
  <subtitle>追寻着丢失的气球...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ecnudayun.coding.me/"/>
  <updated>2018-06-24T01:51:18.604Z</updated>
  <id>https://ecnudayun.coding.me/</id>
  
  <author>
    <name>Da yun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>并行程序（四）OPENMP</title>
    <link href="https://ecnudayun.coding.me/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%88%E5%9B%9B%EF%BC%89OPENMP/"/>
    <id>https://ecnudayun.coding.me/并行程序（四）OPENMP/</id>
    <published>2018-06-15T00:55:51.000Z</published>
    <updated>2018-06-24T01:51:18.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="并行之OpenMP"><a href="#并行之OpenMP" class="headerlink" title="并行之OpenMP"></a>并行之<code>OpenMP</code></h3><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>当时学c的时候并没有关注预处理</p><p>常用的预处理</p><p>宏定义(<code>#define</code>)、文件包含(<code>#include</code>)、条件编译(<code>#ifdef</code>)</p><a id="more"></a><p>写给编译器看的,告诉它一些事情</p><p>我们在<code>OpenMP</code>里面要用到的是下面这样的格式</p><p><strong>格式：</strong></p><table><thead><tr><th>pragma omp</th><th>directive-name</th><th>[clause, …]</th><th>newline</th></tr></thead><tbody><tr><td>所有OpenMP C/C++指令都需要由此开头。</td><td>一个合法的OpenMP指令。需要出现在pragma之后，所有其它从句之前。</td><td>可选。从句可以以任意次序出现，并且可以在需要的时候重复出现出现（特殊情况除外）。</td><td>必须。先于本指令附带的结构化块出现。</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp parallel default(shared) private(beta,pi)1</span><br></pre></td></tr></table></figure><p><strong>一般规则</strong>：1）大小写敏感；2）<code>OpenMP</code>指令遵循C/C++指令的标准约定；3）每个指令只能指定一个指令名；4）每个指令最多只适用于一个后续的声明，而且该后续声明必须是一个结构化的块；5）在之领航的末尾通过使用反斜杠“\”转移换行符，可以在后续行上“延续”长指令行。</p><p>看到这里如果不懂没关系</p><h5 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h5><p>先看看<code>helloworld</code></p><img src="/并行程序（四）OPENMP/helloworldOPENMP.jpg"><p><code># pragma omp parallel num_threads(thread_count)</code></p><p>先看看这句简单的指令</p><p><code>pragma omp</code>是每个<code>OpenMP</code>都有的，然后<code>parallel</code>是指定多线程，<code>num_threads</code>是指定线程的个数</p><p>每个线程都会执行代码块中的代码</p><p>并且有一个<font color="red">隐式路障</font></p><p>所有线程完成上面代码中的hello函数后会等待其他进程完成</p><p>两个基本的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">omp_get_threadnum();<span class="comment">//返回当前线程的编号</span></span><br><span class="line">omp_get_num_threads();<span class="comment">//返回线程组中线程的个数</span></span><br></pre></td></tr></table></figure><h5 id="互斥访问"><a href="#互斥访问" class="headerlink" title="互斥访问"></a>互斥访问</h5><p>OpenMP中支持互斥访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#progma omp critical</span></span><br><span class="line">global_result+=my_result;</span><br></pre></td></tr></table></figure><h5 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h5><p>main函数中的变量对每个线程都是可以访问的，指令的代码块里的函数里面的声明的变量是每个线程私有的</p><h5 id="归约变量的使用-貌似没什么用"><a href="#归约变量的使用-貌似没什么用" class="headerlink" title="归约变量的使用(貌似没什么用)"></a>归约变量的使用(貌似没什么用)</h5><p>在一些把所有私有变量加到或者减到一个全局变量里面，为了清晰代码，为了避免变成串行程序（看下面的例子）</p><p>举个栗子</p><p>串行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    sum+=A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这玩意直接写成OpenMP</p><p>不使用归约的话是(plus返回这个线程私有变量的local和)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">sum+=plus()</span><br></pre></td></tr></table></figure><p>显而易见，sum是所有线程都可访问的，会导致结果不正确</p><p>加上互斥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta"># progma omp critical</span></span><br><span class="line">    sum+=plus()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样巧妙的变成了一个无效的并行</p><p>但很容易想到使用一个私有变量来保存结果，再把这个私有的结果在临界区里面加起来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> local_sum=plus();</span><br><span class="line">    <span class="meta"># progma omp critical</span></span><br><span class="line">    sum+=local_sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归约就很智障的等价于上面这个代码</p><p>使用归约代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> omp parallel num_threads(thread_count)\</span></span><br><span class="line">reduction(+:sum)</span><br><span class="line">&#123;</span><br><span class="line">    sum+=plus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parallel-for"><a href="#parallel-for" class="headerlink" title="parallel for"></a>parallel for</h4><p>看例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="meta"># progma omp parallel for num_threads(thread_count)\</span></span><br><span class="line">reduction(+: sum)</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    sum+=plus();</span><br></pre></td></tr></table></figure><p>OpenMP FOR只能用于严格的for循环语句</p><p>并且里面不处理函数的互相依赖，函数的互相依赖由程序员自己解决</p><h5 id="算pi-包含依赖问题的解决以及private的用法"><a href="#算pi-包含依赖问题的解决以及private的用法" class="headerlink" title="算pi  包含依赖问题的解决以及private的用法"></a>算pi  包含依赖问题的解决以及private的用法</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> factor=<span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">double</span> sum=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">100</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line">reduction(+:sum)</span><br><span class="line"><span class="keyword">for</span> (k=<span class="number">0</span>,k&lt;n,k++)(   <span class="comment">//这里面的k在 parallel for里面会是私有的</span></span><br><span class="line">    sum+=factor/(<span class="number">2</span>*k+<span class="number">1</span>);</span><br><span class="line">    factor=-factor;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">int</span> pi=<span class="number">4.0</span>*sum;</span><br></pre></td></tr></table></figure><p>这段代码很明显有一个函数的依赖</p><p>factor的正负因为并行，变得不可确定</p><p>替代方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(k%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    factor=<span class="number">1.0</span>；</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">factor=<span class="number">-1.0</span>;</span><br></pre></td></tr></table></figure><p>然后这里会有一个不容易想到的错误，factor是一个所有线程都可见的，那么并行的时候，很容易就出错了</p><p>OpenMP中支持private，作用域仅在指令对应的代码块中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">pragma</span> omp parallel for num_threads(thread_count)\</span></span><br><span class="line">reduction(+:sum) <span class="keyword">private</span>(factor)</span><br></pre></td></tr></table></figure><p>改成这样就可以了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;并行之OpenMP&quot;&gt;&lt;a href=&quot;#并行之OpenMP&quot; class=&quot;headerlink&quot; title=&quot;并行之OpenMP&quot;&gt;&lt;/a&gt;并行之&lt;code&gt;OpenMP&lt;/code&gt;&lt;/h3&gt;&lt;h4 id=&quot;预处理&quot;&gt;&lt;a href=&quot;#预处理&quot; class=&quot;headerlink&quot; title=&quot;预处理&quot;&gt;&lt;/a&gt;预处理&lt;/h4&gt;&lt;p&gt;当时学c的时候并没有关注预处理&lt;/p&gt;
&lt;p&gt;常用的预处理&lt;/p&gt;
&lt;p&gt;宏定义(&lt;code&gt;#define&lt;/code&gt;)、文件包含(&lt;code&gt;#include&lt;/code&gt;)、条件编译(&lt;code&gt;#ifdef&lt;/code&gt;)&lt;/p&gt;
    
    </summary>
    
    
      <category term="并行程序" scheme="https://ecnudayun.coding.me/tags/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>并行程序（三）Pthread</title>
    <link href="https://ecnudayun.coding.me/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%89%EF%BC%89Pthread/"/>
    <id>https://ecnudayun.coding.me/并行程序（三）Pthread/</id>
    <published>2018-06-14T11:01:51.000Z</published>
    <updated>2018-06-14T13:37:40.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Pthread"><a href="#Pthread" class="headerlink" title="`Pthread"></a>`Pthread</h3><h5 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_t</span> thread, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> attr, </span></span></span><br><span class="line">void* (*start_routine)(void*), </span><br><span class="line"><span class="keyword">void</span>* arg);</span><br></pre></td></tr></table></figure><p>参数分析</p><a id="more"></a><p>第一个参数是指针对应的是<code>Pthread_t</code>对象<code>Pthread_t</code>对象的空间是在调用函数之前自己要声明的</p><p>第二个参数一般不用，写NULL就可以了</p><p>第三个参数是调用的函数</p><p>第四个也是个指针</p><h5 id="合并进程"><a href="#合并进程" class="headerlink" title="合并进程"></a>合并进程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_t</span> thread,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span>** ret_val_p</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><h4 id="避免并行时的一些错误"><a href="#避免并行时的一些错误" class="headerlink" title="避免并行时的一些错误"></a>避免并行时的一些错误</h4><h5 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h5><p>未使用忙等待的函数是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y=compute(my_rank);</span><br><span class="line">x=x+y;</span><br></pre></td></tr></table></figure><p>因为读取x还未写回的时候可能被其他进程写造成其他进程的写最后被覆盖</p><p>使用忙等：（可能会因为编译器的优化导致失效）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">y=compute(my_rank);</span><br><span class="line"><span class="keyword">while</span>(my_rank!=flag);</span><br><span class="line">x=x+y</span><br><span class="line">flag++;</span><br></pre></td></tr></table></figure><p>保证一定的正确性，但是使用忙等待会有效率问题</p><p>操作系统调用各个进程是随机的，所以flag不等于my_rank的概率挺大的，会造成效率比较低</p><h5 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h5><p>创建锁(这个函数考试一定不会考，下面几个函数也)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_mutex_t</span>* mutex_p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span>* attr_p</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</span><br></pre></td></tr></table></figure><p>解锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</span><br></pre></td></tr></table></figure><p>del 锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex_p)</span></span>;</span><br></pre></td></tr></table></figure><p>互斥锁的性能在进程数多余核数的时候，效率依然很高，忙等就不行了</p><h5 id="信号量-估计也不会考"><a href="#信号量-估计也不会考" class="headerlink" title="信号量(估计也不会考)"></a>信号量(估计也不会考)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要有头文件</span></span><br><span class="line"><span class="meta">#indlude <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">sem_t</span>* semaphore_p,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> shared,<span class="comment">//为0就可以了</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">unsigned</span> initial_val</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span></span>;<span class="comment">//加1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>* semaphore_p)</span></span>;<span class="comment">//不为0就减1，阻塞到为正数的时候</span></span><br></pre></td></tr></table></figure><h5 id="同步点（路障）"><a href="#同步点（路障）" class="headerlink" title="同步点（路障）"></a>同步点（路障）</h5><p>1）忙等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(counter&lt;thread_count);</span><br></pre></td></tr></table></figure><p>2)信号量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sem_wait(&amp;count_sem);</span><br><span class="line"><span class="keyword">if</span>(counter == thread_count<span class="number">-1</span>)&#123;</span><br><span class="line">    counter = <span class="number">0</span>;</span><br><span class="line">    sem_post(&amp;count_sem);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;thread_count<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        sem_post(&amp;barrier_sem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    counter++;</span><br><span class="line">    sem_post(&amp;count_sem);</span><br><span class="line">    sem_wait(&amp;barrier_sem);<span class="comment">//它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>count_sem</code>是用来保护计数的</p><p><code>barrier_sem</code>是路障</p><p>有点难懂，一步一步分析</p><p>第一步，跑的最快的进程来到了第一行，<code>count_sem</code>此时是1（初始值），此时count是0，来到这里的是跑的最快的那个，此时<code>count_sem</code>减1，后面的人就过不了这个锁了，然后进入else语句，counter++，毕竟这第一把锁就为了保护counter++，post把锁打开</p><p>然后第一个进程被锁住了，遇到了路障，此时<code>barrier_sem</code>的值为0，他被拦住了，并且现在还不可以修改信号量</p><p>同样的第二快的进程也将会在这里等着，</p><p>直到最后一个进程，他进入的是if语句 他在解开<code>count_sem</code>之后需要把路障打开，他调用一次post，就有被拦住的的进程可以调用wait来-1并通过路障，总共调用了总数-1次，因为最后这个没有锁这里</p><p>3）条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond_var_p)</span></span>;<span class="comment">//解锁一个线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond_var_p)</span></span>;<span class="comment">//解锁所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_cond_t</span>* cond_var_p;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_mutex_t</span>* mutex_p</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;<span class="comment">//通过mutex_p来阻塞线程，直到被其他的解锁，当线程解锁后重新获得互斥量</span></span><br></pre></td></tr></table></figure><p>实现路障</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">counter++;</span><br><span class="line"><span class="keyword">if</span>(counter==thread_count)&#123;</span><br><span class="line">    counter=<span class="number">0</span>;</span><br><span class="line">    pthread_cond_broadcast(&amp;cond_var);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(pthread_cond_wait(&amp;cond_var,&amp;mutex)!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><p>看看<code>pthread_cond_wait</code>函数的注释大概理解下就行</p><p>只有在被<code>pthread_cond_signal</code> <code>pthread_cond_broadcast</code>解锁的时候<code>pthread_cond_wait</code>返回值会是0</p><h5 id="细粒度锁"><a href="#细粒度锁" class="headerlink" title="细粒度锁"></a>细粒度锁</h5><p>书上提到了在对链表访问的时候可以考虑对每个节点进行加锁增加并行性</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Pthread&quot;&gt;&lt;a href=&quot;#Pthread&quot; class=&quot;headerlink&quot; title=&quot;`Pthread&quot;&gt;&lt;/a&gt;`Pthread&lt;/h3&gt;&lt;h5 id=&quot;创建进程&quot;&gt;&lt;a href=&quot;#创建进程&quot; class=&quot;headerlink&quot; title=&quot;创建进程&quot;&gt;&lt;/a&gt;创建进程&lt;/h5&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;pthread_t&lt;/span&gt; thread, &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;pthread_attr_t&lt;/span&gt; attr, &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	void* (*start_routine)(void*), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;* arg);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;参数分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="并行程序" scheme="https://ecnudayun.coding.me/tags/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>并行程序（二）MPI</title>
    <link href="https://ecnudayun.coding.me/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%BA%8C%EF%BC%89MPI/"/>
    <id>https://ecnudayun.coding.me/并行程序（二）MPI/</id>
    <published>2018-06-14T01:03:59.000Z</published>
    <updated>2018-06-14T13:37:24.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MPI"><a href="#MPI" class="headerlink" title="MPI"></a>MPI</h3><h4 id="“hello-world”"><a href="#“hello-world”" class="headerlink" title="“hello world”"></a>“hello world”</h4><a id="more"></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_string=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> totalTaskNum, rankID;  </span><br><span class="line">      <span class="keyword">char</span> greeting[max_string];</span><br><span class="line">        MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        MPI_Comm_size(MPI_COMM_WORLD, &amp;totalTaskNum);  </span><br><span class="line">        MPI_Comm_rank(MPI_COMM_WORLD, &amp;rankID);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(rankID==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Greeting from process %d of %d"</span>,rankID,totalTaskNum);</span><br><span class="line">        <span class="keyword">int</span> q=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (q=<span class="number">1</span>;q&lt;totalTaskNum;q++)&#123;</span><br><span class="line">      MPI_Recv(greeting,max_string,MPI_CHAR,q,<span class="number">0</span>,MPI_COMM_WORLD,MPI_STATUS_IGNORE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,greeting);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(greeting,<span class="string">"Greeting from process %s of %d"</span>,rankID,totalTaskNum);</span><br><span class="line">        MPI_SEND(greeting,<span class="built_in">strlen</span>(greeting)+<span class="number">1</span>,MPI_CHAR,<span class="number">0</span>,<span class="number">0</span>,MPI_COMM_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">        MPI_Finalize();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序分析</p><p>基本操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MPI_Init(<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">MPI_Comm_size(MPI_COMM_WORLD, &amp;totalTaskNum);  </span><br><span class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;rankID);</span><br></pre></td></tr></table></figure><p><code>MPI_COMM_WORLD</code>是通信子</p><p><code>send</code>函数里面最后一个参数是通信子，倒数第二个是tag（<strong>每个通信里面要保证tag不同</strong>），倒数第三个是目的地</p><p><code>recv</code>函数里面最后一个是<code>MPI_STATUS</code>，一般忽略，使用 <code>MPI_STATUS_IGNORE</code> ，倒数第三个是tag，倒数第四个是source</p><p><code>MPI_Recv</code>总是阻塞的，直到收到一条消息</p><h4 id="集合通信"><a href="#集合通信" class="headerlink" title="集合通信"></a>集合通信</h4><h5 id="MPI-Reduce"><a href="#MPI-Reduce" class="headerlink" title="MPI_Reduce"></a><code>MPI_Reduce</code></h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Reduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* input,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span>* output,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Datatype datatype,</span></span></span><br><span class="line"><span class="function"><span class="params">    MPI_Op <span class="keyword">operator</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">int</span> dest_process,</span></span></span><br><span class="line">    MPI_Com comm)；</span><br></pre></td></tr></table></figure><p>看看参数就明白这是做什么的了</p><p><strong>把结果只返回给一个进程</strong></p><p><code>MPI_Op</code>是调用函数，<code>MPI_SUM</code>就是用来求所有的和的</p><h5 id="MPI-Allreduce"><a href="#MPI-Allreduce" class="headerlink" title="MPI_Allreduce"></a><code>MPI_Allreduce</code></h5><p>把reduce函数里面的dest删了就行了，每个进程都可以得到最后的结果</p><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Bcast</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span>* data,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype type,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> source_proc,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Comm comm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>从参数上看，浅显易懂</p><p>把source处的一个进程的数据 通过广播的方式发给每一个进程</p><h4 id="散射"><a href="#散射" class="headerlink" title="散射"></a>散射</h4><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><p>一般用来分发向量</p><h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MPI_Scatter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span>* send_buf,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> send_count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype send_type,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span>* recv_buf,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> recv_count,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Datatype recv_type,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> src_proc,</span></span></span><br><span class="line"><span class="function"><span class="params">MPI_Comm comm</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数常用于可以被整除的情况</p><p><code>send_count</code> <code>recv_count</code>里面都是local_n，就是发给或者每个进程收到的数据大小</p><h4 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h4><h5 id="MPI-Gather"><a href="#MPI-Gather" class="headerlink" title="MPI_Gather"></a><code>MPI_Gather</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MPI_Gather(</span><br><span class="line">    <span class="keyword">void</span>* send_buf,</span><br><span class="line">    <span class="keyword">int</span> send_count,</span><br><span class="line">    MPI_Datatype send_datatype,</span><br><span class="line">    <span class="keyword">void</span>* recv_buf,</span><br><span class="line">    <span class="keyword">int</span> recv_count,<span class="comment">//注意该参数表示的是从单个进程接收的数据个数，不是总数</span></span><br><span class="line">    MPI_Datatype recv_datatype,</span><br><span class="line">    <span class="keyword">int</span> dest,</span><br><span class="line">    MPI_Comm communicator)</span><br></pre></td></tr></table></figure><p>与scatter是刚好反着的</p><h5 id="MPI-Allgather"><a href="#MPI-Allgather" class="headerlink" title="MPI_Allgather"></a><code>MPI_Allgather</code></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MPI_Allgather(</span><br><span class="line">    void* send_buf,</span><br><span class="line">    int send_count,</span><br><span class="line">    MPI_Datatype send_datatype,</span><br><span class="line">    void* recv_buf,</span><br><span class="line">    int recv_count,</span><br><span class="line">    MPI_Datatype recv_datatype,</span><br><span class="line">    MPI_Comm communicator)</span><br></pre></td></tr></table></figure><p>每个进程都可以得到最终的结果</p><h4 id="MPI派生数据类型"><a href="#MPI派生数据类型" class="headerlink" title="MPI派生数据类型"></a>MPI派生数据类型</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>为了节省传数据的时间，能一次发送的，绝不调用两个函数</p><p>把多种数据类型合并成一个向量发出去就行了</p><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>派生数据由一系列<strong>MPI基本数据</strong>加上每个<strong>数据的相对于起始偏移</strong>组成</p><p>{(MPI_DOUBLE,0),(MPI_DOUBLE,16),(MPI_INT,24)}</p><p>使用构造函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">MPI_Type_create_struct</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span> array_of_blocklengths[],</span></span></span><br><span class="line"><span class="function"><span class="params">  MPI_Aint array_of_displacements[],</span></span></span><br><span class="line"><span class="function"><span class="params">  MPI_Datatype array_of_types[],</span></span></span><br><span class="line"><span class="function"><span class="params">  MPI_Datatype *newtype</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p> 迷幻的函数，直接从<a href="http://mpi.deino.net/mpi_functions/MPI_Type_create_struct.html" target="_blank" rel="noopener">不知道是啥网站</a>抄一段代码</p><p>注释是我自己加的</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mpi.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Partstruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">double</span> d[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">7</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Partstruct</span> <span class="title">particle</span>[1000];</span></span><br><span class="line">    <span class="keyword">int</span> i, j, myrank;</span><br><span class="line">MPI_Status status;</span><br><span class="line">MPI_Datatype Particletype;</span><br><span class="line">MPI_Datatype type[<span class="number">3</span>] = &#123; MPI_CHAR, MPI_DOUBLE, MPI_CHAR &#125;;</span><br><span class="line">    <span class="keyword">int</span> blocklen[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span> &#125;; <span class="comment">//每个数据结构自己的长度</span></span><br><span class="line">MPI_Aint disp[<span class="number">3</span>];  <span class="comment">//地址偏移</span></span><br><span class="line">MPI_Init(&amp;argc, &amp;argv);</span><br><span class="line">disp[<span class="number">0</span>] = &amp;particle[<span class="number">0</span>].c - &amp;particle[<span class="number">0</span>];  <span class="comment">//计算偏移</span></span><br><span class="line">disp[<span class="number">1</span>] = &amp;particle[<span class="number">0</span>].d - &amp;particle[<span class="number">0</span>];</span><br><span class="line">disp[<span class="number">2</span>] = &amp;particle[<span class="number">0</span>].b - &amp;particle[<span class="number">0</span>];</span><br><span class="line">MPI_Type_create_struct(<span class="number">3</span>, blocklen, disp, type, &amp;Particletype); <span class="comment">//调用函数构造</span></span><br><span class="line">MPI_Type_commit(&amp;Particletype);  <span class="comment">//使用之前要先用commit去指定</span></span><br><span class="line">MPI_Comm_rank(MPI_COMM_WORLD, &amp;myrank);</span><br><span class="line">    <span class="keyword">if</span> (myrank == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">MPI_Send(particle, <span class="number">1000</span>, Particletype, <span class="number">1</span>, <span class="number">123</span>, MPI_COMM_WORLD);<span class="comment">//把空的数据结构传来传去...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (myrank == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">MPI_Recv(particle, <span class="number">1000</span>, Particletype, <span class="number">0</span>, <span class="number">123</span>, MPI_COMM_WORLD, &amp;status);</span><br><span class="line">&#125;</span><br><span class="line">MPI_Finalize();<span class="comment">//结束</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MPI性能评估"><a href="#MPI性能评估" class="headerlink" title="MPI性能评估"></a>MPI性能评估</h4><h5 id="计时"><a href="#计时" class="headerlink" title="计时"></a>计时</h5><p><code>start=MPI_Wtime</code></p><p><code>end=MPI_Wtime</code></p><p><code>time=end-start</code></p><h5 id="开销"><a href="#开销" class="headerlink" title="开销"></a>开销</h5><p>T<sub>并行</sub>(n,p)=T<sub>串行</sub>(n)/p+T<sub>开销</sub></p><h5 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h5><p>S(n,p)=T<sub>串行</sub>(n)/T<sub>并行</sub>(n,p)</p><h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h5><p>E(n,p)=S(n,p)/p</p><p>通常都小于1</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;MPI&quot;&gt;&lt;a href=&quot;#MPI&quot; class=&quot;headerlink&quot; title=&quot;MPI&quot;&gt;&lt;/a&gt;MPI&lt;/h3&gt;&lt;h4 id=&quot;“hello-world”&quot;&gt;&lt;a href=&quot;#“hello-world”&quot; class=&quot;headerlink&quot; title=&quot;“hello world”&quot;&gt;&lt;/a&gt;“hello world”&lt;/h4&gt;
    
    </summary>
    
    
      <category term="并行程序" scheme="https://ecnudayun.coding.me/tags/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>并行程序（一）</title>
    <link href="https://ecnudayun.coding.me/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://ecnudayun.coding.me/并行程序（一）/</id>
    <published>2018-06-13T12:36:18.000Z</published>
    <updated>2018-06-24T07:23:45.481Z</updated>
    
    <content type="html"><![CDATA[<p>注：很久没更新了，懒了，学不会了</p><h3 id="并行程序第一章"><a href="#并行程序第一章" class="headerlink" title="并行程序第一章"></a>并行程序第一章</h3><h4 id="为甚么要并行"><a href="#为甚么要并行" class="headerlink" title="为甚么要并行"></a>为甚么要并行</h4><p>单核系统的发展受到阻碍，并行大法好</p><h4 id="两种并行方式"><a href="#两种并行方式" class="headerlink" title="两种并行方式"></a>两种并行方式</h4><h5 id="任务并行-数据并行"><a href="#任务并行-数据并行" class="headerlink" title="任务并行 数据并行"></a>任务并行 数据并行</h5><a id="more"></a><p>举个栗子：</p><p>老师和四个助教给100个学生的五道题打分</p><p>第一种方式：每个人负责一个问题打分（任务并行）（<strong>执行不同的指令</strong>）</p><p>第二种方式：把学生分为5组（数据并行）（每个<strong>核</strong>做的都是相同的指令）</p><h4 id="三种协调工作"><a href="#三种协调工作" class="headerlink" title="三种协调工作"></a>三种协调工作</h4><h5 id="通信-负载平衡-同步"><a href="#通信-负载平衡-同步" class="headerlink" title="通信 负载平衡 同步"></a>通信 负载平衡 同步</h5><h4 id="并行化步骤"><a href="#并行化步骤" class="headerlink" title="并行化步骤"></a>并行化步骤</h4><h5 id="划分-通信-聚合-分配（分配到进程中）"><a href="#划分-通信-聚合-分配（分配到进程中）" class="headerlink" title="划分 通信 聚合 分配（分配到进程中）"></a>划分 通信 聚合 分配（分配到进程中）</h5><h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="cache映射"><a href="#cache映射" class="headerlink" title="cache映射"></a>cache映射</h5><p><strong>全相联</strong> 每个高速缓存行能放在Cache的任意位置</p><p><strong>直接相联</strong> 每个高速缓存行有特殊的位置</p><p><strong>N路组相联</strong> 每个高速缓存行都可以放置在n个不同区域位置的一个</p><p>举个栗子：</p><p>16行主存映射到4行cache</p><p>全相联的话，1到16通通可以随机分配到0,1,2,3,</p><p>直接映射：mod 4为多少就放在那个cache</p><p>2路组相联：mod (4/2)为1的放在2或3      mod (4/2)为0的放在0或1</p><p>注意：每次miss后  读取的会是缓存中的一行</p><p><strong>替换方案</strong>通常是最近最少使用</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注：很久没更新了，懒了，学不会了&lt;/p&gt;
&lt;h3 id=&quot;并行程序第一章&quot;&gt;&lt;a href=&quot;#并行程序第一章&quot; class=&quot;headerlink&quot; title=&quot;并行程序第一章&quot;&gt;&lt;/a&gt;并行程序第一章&lt;/h3&gt;&lt;h4 id=&quot;为甚么要并行&quot;&gt;&lt;a href=&quot;#为甚么要并行&quot; class=&quot;headerlink&quot; title=&quot;为甚么要并行&quot;&gt;&lt;/a&gt;为甚么要并行&lt;/h4&gt;&lt;p&gt;单核系统的发展受到阻碍，并行大法好&lt;/p&gt;
&lt;h4 id=&quot;两种并行方式&quot;&gt;&lt;a href=&quot;#两种并行方式&quot; class=&quot;headerlink&quot; title=&quot;两种并行方式&quot;&gt;&lt;/a&gt;两种并行方式&lt;/h4&gt;&lt;h5 id=&quot;任务并行-数据并行&quot;&gt;&lt;a href=&quot;#任务并行-数据并行&quot; class=&quot;headerlink&quot; title=&quot;任务并行 数据并行&quot;&gt;&lt;/a&gt;任务并行 数据并行&lt;/h5&gt;
    
    </summary>
    
    
      <category term="并行程序" scheme="https://ecnudayun.coding.me/tags/%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库第十章</title>
    <link href="https://ecnudayun.coding.me/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <id>https://ecnudayun.coding.me/数据库第十章/</id>
    <published>2018-05-23T11:44:13.000Z</published>
    <updated>2018-05-23T15:34:41.807Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>spring boot学习第一天</title>
    <link href="https://ecnudayun.coding.me/springboot%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <id>https://ecnudayun.coding.me/springboot学习第一天/</id>
    <published>2018-05-19T00:40:32.000Z</published>
    <updated>2018-05-19T07:23:16.745Z</updated>
    
    <content type="html"><![CDATA[<h4 id="开始学习spring-boot"><a href="#开始学习spring-boot" class="headerlink" title="开始学习spring boot"></a>开始学习spring boot</h4><p>学习原因：做网站，spring boot开发起来据说比较方便</p><p>本系列文章仅作为本人自学使用，其他人学习请转移官方文档，因为我啥都不会，难免会写错一些东西</p><p>使用idea这个ide，所以跳过spring boot的环境配置，dependence是idea自动生成的，暂时也不研究。</p><a id="more"></a><p>下面正式开始：</p><p>####hello world</p><p><code>src/main/java</code>下的源码会自动编译</p><p>在这个目录下创建一个<code>Example.java</code>文件（idea自动生成的话会有一个<code>main</code>函数的java文件），所以下面这段代码通常会放在两个不同的<code>.java</code>文件中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SpringApplication.run(Example.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解在spring boot里面，理解成调用了一段代码</p><p>首先简单理解下<code>@RestController</code>这是一条注解，这条注解作用域下面的的<code>return &quot;xxx&quot;</code> 返回的是字符串，在网页中直接将“xxx”打出来</p><p>类似的注解有<code>@Controller</code>这条注解<code>return &quot;xxx&quot;</code>返回的将是<code>xxx.html</code> </p><p>这两个controller注解都是提供路由信息，控制页面跳转的</p><p><code>@RequestMapping</code>注解提供路由信息，它告诉Spring任何来自”/“路径的HTTP请求都应该被映射到<code>home</code>方法。</p><p><code>@EnableAutoConfiguration</code>会自动去配置spring boot</p><p>main函数基本上都是这样写的，idea会自动写好，整个项目都会从这里开始运行</p><p>然后，。。没有找到合适的教程了，适合我这种菜鸡的</p><p>只好实现任务驱动学习</p><h4 id="session登录"><a href="#session登录" class="headerlink" title="session登录"></a>session登录</h4><p>想学下简单的session控制登录</p><p>找了一个别人写的 感觉还代码量比较少的</p><p><a href="https://blog.csdn.net/huang906391/article/details/78376766" target="_blank" rel="noopener">去这个博客下载</a></p><p>下下来之后比较蠢的我开心的看见他也是使用idea写的，于是，直接导入，运行，失败</p><p>蠢蠢的我意识到可能是数据库配置问题</p><p>改成了我的数据库</p><p>继续失败</p><p>浏览了一遍代码，没有看到有sql语言，懵逼，删除文件，再见</p><p>第二天 我又下下来，终于我发现了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginDao</span> <span class="keyword">extends</span> <span class="title">CrudRepository</span>&lt;<span class="title">User</span> , <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findByUsernameAndPassword</span><span class="params">(String name,String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么一段代码</p><p>通过百度</p><p><code>@Repository</code>用于标注数据访问组件，即DAO组件；DAO组件是啥，百度一下，居然是数据库操作的</p><p><code>CrudRepository</code>这个接口，学习一下</p><p>一篇不错的教程</p><p><a href="https://blog.csdn.net/youngsend/article/details/51832581" target="_blank" rel="noopener">CrudRepository</a></p><p>功能和用法都刷新了我对spring的认知</p><p>下面继续来看数据库部分，方法名里面的Username和实际数据库中的名字是怎样对应起来的的呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Entity</span><br><span class="line">@Table(name=&quot;tb_user_management&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    </span><br><span class="line">    @Id</span><br><span class="line">    @Column(name = &quot;id&quot;)</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.AUTO)</span><br><span class="line">    private long id;</span><br><span class="line">    </span><br><span class="line">    @Column(name = &quot;userid&quot;)</span><br><span class="line">    private String userid;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;username&quot;)</span><br><span class="line">    private String username;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;password&quot;)</span><br><span class="line">    private String password;</span><br><span class="line"></span><br><span class="line">    @Column(name = &quot;userps&quot;)</span><br><span class="line">    private String userps;</span><br></pre></td></tr></table></figure><p>看看user对象的定义部分</p><p><code>@Id</code> 标注用于声明一个实体类的属性映射为数据库的主键列</p><p><code>@Column</code>注解来标识实体类中属性与数据表中字段的对应关系</p><p><code>@GeneratedValue</code>  用于标注主键的生成策略，通过strategy 属性指定。</p><p>通过注解，就可以实现java中的对象与数据库中的属性名进行一一对应了</p><p>在数据库中，我发现在对应的表里面自动创建了一张表</p><p>在<code>application.properties</code>文件中我发现了一条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br></pre></td></tr></table></figure><p>其实这个hibernate.hbm2ddl.auto参数的作用主要用于：自动创建|更新|验证数据库表结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;开始学习spring-boot&quot;&gt;&lt;a href=&quot;#开始学习spring-boot&quot; class=&quot;headerlink&quot; title=&quot;开始学习spring boot&quot;&gt;&lt;/a&gt;开始学习spring boot&lt;/h4&gt;&lt;p&gt;学习原因：做网站，spring boot开发起来据说比较方便&lt;/p&gt;
&lt;p&gt;本系列文章仅作为本人自学使用，其他人学习请转移官方文档，因为我啥都不会，难免会写错一些东西&lt;/p&gt;
&lt;p&gt;使用idea这个ide，所以跳过spring boot的环境配置，dependence是idea自动生成的，暂时也不研究。&lt;/p&gt;
    
    </summary>
    
    
      <category term="springboot" scheme="https://ecnudayun.coding.me/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>凑日更之python语法篇</title>
    <link href="https://ecnudayun.coding.me/%E5%87%91%E6%97%A5%E6%9B%B4%E4%B9%8Bpython%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    <id>https://ecnudayun.coding.me/凑日更之python语法篇/</id>
    <published>2018-05-05T01:35:17.000Z</published>
    <updated>2018-05-14T15:51:38.457Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅作为对某些（主要用来凑更）语法知识的回顾与复习，面向百度书（xia）写</p><p>适合 <del>所有人</del> 本来就知道这些的人观看</p><p>写了一会儿之后发现有点长。。。。。</p><h4 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h4><h5 id="基础编码编码"><a href="#基础编码编码" class="headerlink" title="基础编码编码"></a>基础编码编码</h5><p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码</p><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p><code>#</code>用来注释</p><p>多行的注释可以选择多个<code>#</code>或者</p><p>使用<code>&#39;&#39;&#39;</code>或者<code>&quot;&quot;&quot;</code>来注释</p><a id="more"></a><h5 id="代码基本输入"><a href="#代码基本输入" class="headerlink" title="代码基本输入"></a>代码基本输入</h5><p>一般的教程可能没写</p><p>用手指一个一个按，对的</p><p>python有个很人xing的设计，行末没有<code>;</code></p><p>这个设计很棒可以增大键盘上 向右键 的寿命；</p><p>一行如果想弄多个语句，比如想把10行代码弄到一行，ok，用；分割他们</p><p><strong>空行</strong></p><p>python3语法中对空行没有要求，空行仅仅是对程序员友好的一种工具</p><h5 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h5><p>当你输入的时候某些原因你把好好的一句代码弄成多行</p><p>python3的编译器表示不认识</p><p>这个时候使用一手<code>()</code> <code>[]</code> <code>{}</code></p><p>或者用下面这种写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>多行的字符串用三引号</p><p>看例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s=&apos;&apos;&apos;</span><br><span class="line">sada</span><br><span class="line">asdas</span><br><span class="line">asda</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&apos;\nsada\nasdas\nasda\n&apos;</span><br></pre></td></tr></table></figure><h5 id="应用模块"><a href="#应用模块" class="headerlink" title="应用模块"></a>应用模块</h5><p>python中应用的是模块，不是炉石中的那个模块</p><p>模块是.py文件</p><p>多个.py文件构成包</p><p><code>import &lt;包名或者模块名（这个表述不是很准确）&gt;</code>和<code>from &lt;&gt; import &lt;&gt;</code></p><p>&lt;&gt;中写的东西我还不是特别清楚索性不写，基本用法知道会用就行</p><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>python3中很皮</p><h5 id="简单写下整数浮点数问题"><a href="#简单写下整数浮点数问题" class="headerlink" title="简单写下整数浮点数问题"></a>简单写下整数浮点数问题</h5><p>整数与浮点数运算会得到浮点数的结果</p><p>除法（重点）一定得到浮点数 即使结果是真实的计算结果是整数，python3给你的结果也是整数.0</p><p><code>//</code>表示取整除法 两个整数进行这个操作的时候得到的是整数</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p><code>and not or</code>  这个不能写成<code>&amp;&amp; ！ ||</code>  这个设定很不舒服</p><p>所以表示一个数a是偶数的装逼写法在python中的书写就感觉很low</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if not a&amp;1:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="迭代器和生成器（先了解下这个再看基本数据结构）"><a href="#迭代器和生成器（先了解下这个再看基本数据结构）" class="headerlink" title="迭代器和生成器（先了解下这个再看基本数据结构）"></a>迭代器和生成器（先了解下这个再看基本数据结构）</h4><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>我仿佛记得老师说list是迭代器</p><p>但shell告诉我它不是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list=[1,2,3,4]</span><br><span class="line">&gt;&gt;&gt; next(list)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#26&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(list)</span><br><span class="line">TypeError: &apos;list&apos; object is not an iterator</span><br><span class="line">&gt;&gt;&gt; it=iter(list)</span><br><span class="line">&gt;&gt;&gt; next(it)</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>虽然他不是但使用上有一定的相似处，都可以使用for进行迭代，但实现方式其实不太一样</p><p>迭代器的主要的两个函数就是使用<code>iter()</code> ,<code>next()</code></p><p>iter方法是python的一个内建方法，它会返回一个<strong>迭代器对象</strong></p><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>这个东东用到的机会有点少，抽象的介绍下</p><p>使用了 yield 的函数被称为生成器（generator），生成器是一个<strong>返回迭代器</strong>的函数，只能用于迭代操作</p><h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><p><strong>range()函数</strong></p><p>在python2中，这东西返回的还是一个list</p><p>Python3 range() 函数返回的是一个<strong>可迭代对象</strong>（注意和前面iter生成的迭代器对象有区别）</p><p>它也是不能使用next()函数的</p><p>这个时候敏锐的朋友可能猜到，其实字符串，元组，列表，字典也是可迭代对象</p><p>可以实现for遍历的都是可迭代对象</p><p>顺手把for遍历写了，开心</p><p>先来最不同寻常的，字典的遍历</p><p>看下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d=&#123;&apos;python&apos;:1,&apos;php&apos;:2,&apos;java&apos;:3&#125;</span><br><span class="line">&gt;&gt;&gt; d.keys()</span><br><span class="line">dict_keys([&apos;python&apos;, &apos;php&apos;, &apos;java&apos;])</span><br><span class="line">&gt;&gt;&gt; d.values()</span><br><span class="line">dict_values([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; d.items()</span><br><span class="line">dict_items([(&apos;python&apos;, 1), (&apos;php&apos;, 2), (&apos;java&apos;, 3)])</span><br></pre></td></tr></table></figure><p>因为字典中有两个值，一个key值，一个是value值，所以在遍历的时候会有些不太一样的地方，直接遍历得到的是遍历的是key</p><p>自定义的遍历，可以对d.keys()和d.values()和d.items() （这几个返回的都是<strong>可迭代对象</strong>，和list的相似度比较高，但是我试了下，他们不能进行下标访问）进行遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#for key in d.keys():</span><br><span class="line">#for value in d.values():</span><br><span class="line">#for k , v in d.items():</span><br></pre></td></tr></table></figure><p>注：（下面这段不是很必要的操作）</p><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。返回一个<strong>枚举对象</strong>而且这个对象是可以迭代的</p><h4 id="几个自带的常用的数据结构"><a href="#几个自带的常用的数据结构" class="headerlink" title="几个自带的常用的数据结构"></a>几个自带的常用的数据结构</h4><p>字符串，元组，列表，字典，集合</p><p>但是我并不想按顺序写，毕竟看这个的人都是本来就会的人/滑稽</p><p>相同点：</p><p>1.他们都是可迭代对象具体见上面一部分</p><p>2.len()这个函数可以返回字符串、列表、字典、元组、集合等的长度</p><p>官方文档令人信服：</p><blockquote><p>Return the length (the number of items) of an object. The argument may be a<br>sequence (such as a string, bytes, tuple, list, or range) or a collection (such<br>as a dictionary, set, or frozen set).</p></blockquote><p>3.list()实测可以对这几种数据结构进行转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#307&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    list(1)</span><br><span class="line">TypeError: &apos;int&apos; object is not iterable</span><br></pre></td></tr></table></figure><p>我们可以看到只要是可迭代的就可以实现list()函数，实现的效果就是用for遍历出来，然后再打个包加个[]一样</p><p>set() tuple()都是一样的，他们的效果都是差不多的，set操作之后可能顺序不太一样，因为set是无序的</p><p>他们都可以对<strong>可迭代对象</strong>进行操作</p><p>dict()的操作显然就不太一样了，先把官方文档的内容放这里凑字数</p><p>dict() -&gt; new empty dictionary<br> |  dict(mapping) -&gt; new dictionary initialized from a mapping object’s<br> |      (key, value) pairs<br> |  dict(iterable) -&gt; new dictionary initialized as if via:<br> |      d = {}<br> |      for k, v in iterable:<br> |          d[k] = v<br> |  dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs<br> |      in the keyword argument list.  For example:  dict(one=1, two=2)</p><p>4.str() 把所有的的都加上“”，与list()不同，它对参数不进行任何处理直接加””，简单粗暴，注意对本来是字符串的它不处理</p><p>repr()更粗暴，连string类的都加引号</p><p>5.tuple()和list()做的是差不多的事</p><p>对字典操作的时返回的是key值</p><p>对字符串返回的是分开的一个个字符串与list的结果相似</p><p>6.<code>+</code> 操作要求相同的数据结构</p><p> <code>+=</code> 居然不一样，还好我试了一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=&quot;abc&quot;</span><br><span class="line">&gt;&gt;&gt; b=(1,2,3)</span><br><span class="line">&gt;&gt;&gt; c=[4,5,6]</span><br><span class="line">&gt;&gt;&gt; d=&#123;1,2,3&#125;</span><br><span class="line">&gt;&gt;&gt; e=&#123;1:&quot;a&quot;,2:&quot;b&quot;&#125;</span><br></pre></td></tr></table></figure><p>经过测试</p><p>任意两个相加是报错的</p><p>但是！！！！(还好<strong>意外只有一个)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c+=a</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[4, 5, 6, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt; c+=b</span><br><span class="line">&gt;&gt;&gt; c+=d</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[4, 5, 6, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; c+=e</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[4, 5, 6, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3, 1, 2, 3, 1, 2]</span><br></pre></td></tr></table></figure><p>列表实现了自己独特的<u>运算符重载</u> ，在加字典的时候加的是key值</p><p>其实很简单，肉眼能看出来，他们仿佛就是使用了下list()函数之后再相加（当然我是猜的，我没看具体实现方式）</p><p>当然与list的extend方式结果貌似是相同的</p><p>7.<code>*</code> 相当于自己加起来</p><p>8.min()和max()函数，默认的使用方式就是传进去的参数是可迭代的对象，然后对象里面的对象是可以比较大小的 9.    .count()方法，除了集合和字典没有，其他的使用时一样的</p><p>10 .      .pop()方法，默认删除最后一个 string没有这个方法， 集合的pop是不确定是去哪个的，字典的话要指定key作为参数</p><p>b.pop(a)有参数a的时候其实相当于删除b[a]</p><hr><p>相同点差不多就这几点吧</p><p>下面的几点相似度稍微低一点</p><h5 id="support-indexing-（就是用中括号来制定索引）"><a href="#support-indexing-（就是用中括号来制定索引）" class="headerlink" title="support indexing （就是用中括号来制定索引）"></a>support indexing （就是用中括号来制定索引）</h5><p>实测结果，字符串，元组，列表， 字典都有</p><p>其中，string，tuple，list的用法都是相同的</p><p>以list的例子来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list=[&quot;abc&quot;,234,&#123;2,3&#125;]</span><br><span class="line">&gt;&gt;&gt; list</span><br><span class="line">[&apos;abc&apos;, 234, &#123;2, 3&#125;]</span><br><span class="line">&gt;&gt;&gt; list[]</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; list[:]</span><br><span class="line">[&apos;abc&apos;, 234, &#123;2, 3&#125;]</span><br><span class="line">&gt;&gt;&gt; list[::2]</span><br><span class="line">[&apos;abc&apos;, &#123;2, 3&#125;]</span><br></pre></td></tr></table></figure><p>字典的话是使用hash的方式来寻值的</p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;python&apos;: 1, &apos;php&apos;: 2, &apos;java&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; d[:]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#109&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d[:]</span><br><span class="line">TypeError: unhashable type: &apos;slice&apos;</span><br><span class="line">&gt;&gt;&gt; d[1]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#110&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d[1]</span><br><span class="line">KeyError: 1</span><br><span class="line">&gt;&gt;&gt; d[&quot;python&quot;]</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h5 id="id号"><a href="#id号" class="headerlink" title="id号"></a>id号</h5><p>string和元组内容是不可变的</p><p>他们两个的所有的方法是不改变对象本身的</p><p>在id号这件事上我们区别对待</p><p>取string和list进行对比</p><p>string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s=&quot;abcd&quot;</span><br><span class="line">&gt;&gt;&gt; s1=s</span><br><span class="line">&gt;&gt;&gt; id(s)==id(s1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; s+=&quot;d&quot;</span><br><span class="line">&gt;&gt;&gt; id(s)==id(s1)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id([1,2,3])</span><br><span class="line">58631072</span><br><span class="line">&gt;&gt;&gt; l=[1,2,3]</span><br><span class="line">&gt;&gt;&gt; id(l)</span><br><span class="line">58630992</span><br><span class="line">&gt;&gt;&gt; l1=l</span><br><span class="line">&gt;&gt;&gt; id(l)==id(l1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; l.append(4)</span><br><span class="line">&gt;&gt;&gt; id(l)</span><br><span class="line">58630992</span><br><span class="line">&gt;&gt;&gt; id(l1)</span><br><span class="line">58630992</span><br><span class="line">&gt;&gt;&gt; l1</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>具体这是怎么实现的先不管</p><p>我们可以从现象观察到</p><p>1.在最初赋值阶段，变量的id与真正写成“abc”和[1,2,3]的id其实是不同的</p><p>2.但是他们用<code>=</code>进行赋值给其他的变量的时候，其实是把id给人家了，string不可变，所以在改值的时候是用<code>=</code>重新给值了，所以改后的id变了，所以值和原来的不一样；</p><p>list是可变的，对象没变的，操作的是同一个对象，所以id号没变</p><p><strong>另</strong>  list，set，dict都有.copy()方法，返回的对象的id号不同，与使用a[:]的效果相同，id号是不一样的</p><h5 id="修改对象"><a href="#修改对象" class="headerlink" title="修改对象"></a>修改对象</h5><p>string和tuple就只能=进行复制来修改了</p><p>后面的增删改就不考虑他们了</p><p><strong>增加</strong>：</p><p><strong>list</strong>通方法<code>append(obj)</code></p><p>注意这个里面是放的object，直接把对象扔到list里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c=[1,2]</span><br><span class="line">&gt;&gt;&gt; c.append(range(0,4))</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[1, 2, range(0, 4)]</span><br></pre></td></tr></table></figure><p><strong>set</strong>通过<code>add()</code>方法，加的结果是去重的</p><p>字典的比较不同，看下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; e[3]=&apos;c&apos;</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>dict</strong> 可以使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e=&#123;1:&quot;a&quot;,2:&quot;b&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; e[3]=&quot;c&quot;</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong>：</p><p> .pop()方法，默认删除最后一个 string没有这个方法， 集合的pop是不确定是去哪个的，字典的话要指定key作为参数</p><p>b.pop(a)有参数a的时候其实相当于删除b[a]</p><p>.remove()方法</p><p>必须要有参数，参数为指定对象，没有的话抛出异常</p><p>只有set，list有</p><p>pop和remove的主要差别就是一个是索引号指定，一个是object指定</p><p><strong>del</strong> 这是个很厉害的武器,不仅可以对变量操作</p><p>还</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;abc&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; del e[3]</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;&#125;</span><br></pre></td></tr></table></figure><p>直接找到索引删掉，和pop貌似差不多</p><p><strong>改：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[range(0, 9), &apos;a&apos;, &apos;s&apos;, &apos;d&apos;, &apos;a&apos;, &apos;s&apos;]</span><br><span class="line">&gt;&gt;&gt; c[2:3]=(1,2,&quot;2&quot;)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[range(0, 9), &apos;a&apos;, 1, 2, &apos;2&apos;, &apos;d&apos;, &apos;a&apos;, &apos;s&apos;]</span><br><span class="line">&gt;&gt;&gt; c[2:3]=range(9,11)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[range(0, 9), &apos;a&apos;, 9, 10, 2, &apos;2&apos;, &apos;d&apos;, &apos;a&apos;, &apos;s&apos;]</span><br><span class="line">&gt;&gt;&gt; c[0]=range(4)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[range(0, 4), &apos;a&apos;, 9, 10, 2, &apos;2&apos;, &apos;d&apos;, &apos;a&apos;, &apos;s&apos;]</span><br><span class="line">&gt;&gt;&gt; c[0:1]=range(3)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[0, 1, 2, &apos;a&apos;, 9, 10, 2, &apos;2&apos;, &apos;d&apos;, &apos;a&apos;, &apos;s&apos;]</span><br></pre></td></tr></table></figure><p>可见，[0]与[0:1]是不一样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.clear()</span><br><span class="line">&gt;&gt;&gt; c[0]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#154&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c[0]</span><br><span class="line">IndexError: list index out of range</span><br><span class="line">&gt;&gt;&gt; c[0:1]=range(3)</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[0, 1, 2]</span><br></pre></td></tr></table></figure><p>只有list可以进行上面的这种操作</p><p>字典的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; e[3]=&quot;abc&quot;</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;abc&apos;&#125;</span><br></pre></td></tr></table></figure><p>改的话，其实可以通过 删 加完成</p><p><strong>查</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[2, &apos;bcd&apos;]</span><br><span class="line">&gt;&gt;&gt; c.index(2)</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>.index()方法</p><p>string，tuple，list有，参数为对象，返回序列号，没有的话会抛出异常</p><p>还有另一种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[2, &apos;bcd&apos;]</span><br><span class="line">&gt;&gt;&gt; &apos;bcd&apos; in c</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; 1 in e</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>对字典来说，看的是key在不在</p><p>差不多了，先这样，先想到的主要就是这些，其他的改日再写在下一篇博客里</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文仅作为对某些（主要用来凑更）语法知识的回顾与复习，面向百度书（xia）写&lt;/p&gt;
&lt;p&gt;适合 &lt;del&gt;所有人&lt;/del&gt; 本来就知道这些的人观看&lt;/p&gt;
&lt;p&gt;写了一会儿之后发现有点长。。。。。&lt;/p&gt;
&lt;h4 id=&quot;基本规范&quot;&gt;&lt;a href=&quot;#基本规范&quot; class=&quot;headerlink&quot; title=&quot;基本规范&quot;&gt;&lt;/a&gt;基本规范&lt;/h4&gt;&lt;h5 id=&quot;基础编码编码&quot;&gt;&lt;a href=&quot;#基础编码编码&quot; class=&quot;headerlink&quot; title=&quot;基础编码编码&quot;&gt;&lt;/a&gt;基础编码编码&lt;/h5&gt;&lt;p&gt;默认情况下，Python 3 源码文件以 &lt;strong&gt;UTF-8&lt;/strong&gt; 编码&lt;/p&gt;
&lt;h5 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h5&gt;&lt;p&gt;&lt;code&gt;#&lt;/code&gt;用来注释&lt;/p&gt;
&lt;p&gt;多行的注释可以选择多个&lt;code&gt;#&lt;/code&gt;或者&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/code&gt;或者&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;来注释&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://ecnudayun.coding.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>关系模式介绍</title>
    <link href="https://ecnudayun.coding.me/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
    <id>https://ecnudayun.coding.me/关系模式介绍/</id>
    <published>2018-05-02T10:48:21.000Z</published>
    <updated>2018-05-02T11:03:56.175Z</updated>
    
    <content type="html"><![CDATA[<p>本章的类容偏概览，当时学的时候理解的很差，后面的知识学了一些之后再看书好很多</p><h5 id="relation-schema-关系模式"><a href="#relation-schema-关系模式" class="headerlink" title="relation schema 关系模式"></a>relation schema 关系模式</h5><p>一般来说关系模式是 由属性序列及各属性对应域组成</p><h5 id="superkey"><a href="#superkey" class="headerlink" title="superkey"></a>superkey</h5><p>唯一的标识一个元组</p><h5 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h5><p>最小的超码 可以有很多个</p><h5 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h5><p>主要的候选码</p><h5 id="码"><a href="#码" class="headerlink" title="码"></a>码</h5><p>它包括超码，候选码，主码。</p><h5 id="关系查询语言"><a href="#关系查询语言" class="headerlink" title="关系查询语言"></a>关系查询语言</h5><p>过程化 非过程化</p><p>关系代数是过程化的</p><p>元组关系演算和域关系演算是非过程化的（这个貌似没讲也没看）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章的类容偏概览，当时学的时候理解的很差，后面的知识学了一些之后再看书好很多&lt;/p&gt;
&lt;h5 id=&quot;relation-schema-关系模式&quot;&gt;&lt;a href=&quot;#relation-schema-关系模式&quot; class=&quot;headerlink&quot; title=&quot;relati
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关系代数</title>
    <link href="https://ecnudayun.coding.me/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    <id>https://ecnudayun.coding.me/关系代数/</id>
    <published>2018-05-01T14:31:54.000Z</published>
    <updated>2018-05-02T03:31:02.545Z</updated>
    
    <content type="html"><![CDATA[<h5 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h5><p>选择<strong>（Selection）</strong>σ</p><p>投影<strong>（Projection）</strong>Π</p><p>并<strong>（Union）</strong>∪</p><p>集合差<strong>（Difference）</strong>-</p><p>笛卡尔积<strong>（cartesian product）</strong> x</p><p>更名<strong>（rename）</strong>ρ<sub>x</sub></p><a id="more"></a><p>1.选择</p><p>用小写sigma(σ)表示，下标为谓词，括号中为参数关系</p><p>σ<sub>dept_name</sub>=”Physics”(instructor)</p><img src="/关系代数/5.2(1).jpg"><p>2.投影</p><p>返回作为参数的关系，但把某些属性排除在外，所有重复行均被去除。用大写pi(Π)表示，下标为在结果中出现的属性，括号中为参数关系。</p><p>投影操作会去掉重复</p><p>3.并运算</p><p>可将两个集合并起来，找出出现在两个集合之一或同时出现在两个集合中的所有元组。用∪表示。</p><p>要满足两个条件才能进行运算</p><p>a. r,s must have the same arity  (same number of attributes)</p><p>b. The attribute domains must be compatible</p><p>4.集合差</p><p>表达式r-s包含所有在r中而不在s中的元组的关系。</p><p>要满足两个条件才能进行运算</p><p>a. r,s must have the same arity  (same number of attributes)</p><p>b. The attribute domains must be compatible</p><p>5.笛卡尔积</p><p>将任意两个关系的信息组合在一起，结果中包含所有可能的元组对。</p><p>由于相同的属性名可能同时出现在r1和r2中，需要一个命名机制来区别这些属性。可采用把属性所来自的关系名称附加到该属性上的方法。</p><p>笛卡尔积运算参数的关系名称必须不同。</p><p>6.更名操作</p><p>给关系代数表达式的结果赋上名字以供引用，用小写rho(ρ)表示。</p><p>更名运算的另一形式：ρx(A1, A2, …, An)(E)。假设关系代数表达式E是n元的，运算返回表达式E的结果，并把名字x赋给它，同时将各属性更名为A1, A2, …, An。</p><p>e.g. 找出大学里的最高工资</p><p>/*步骤1：计算出一个由非最高工资组成的临时关系。</p><p>首先通过更名运算引用其中一个instructor关系以便计算笛卡尔积instructor×instructor，再构造选择运算比较任意两个出现在同一元组中的salary选择较低的元组。通过投影选取instructor.salary列得到非最高工资构成的临时关系*/</p><p>Πinstructor.salary (σinstructor.salary&lt;d.salary(instructor×ρd(instructor)))</p><p>/*步骤2：计算关系Πsalary (instructor)和刚才计算出的非最高工资构成的临时关系的集合差，</p><p>得到结果。*/</p><p>Πsalary (instructor)-Πinstructor.salary (σinstructor.salary&lt;d.salary(instructor×ρd(instructor)))</p><p>更名运算不是必须的，因为可以用<strong>位置标记</strong>隐含地作为关系（或关系代数表达式运算的结果）的属性名，用$1、$2、…指代第一个属性、第二个属性…以此类推。</p><p>e.g. 用位置标记来计算大学里的非最高工资构成的临时关系</p><p>/*在笛卡尔积(instructor×instructor)中，</p><p>$4代表第一个instructor的属性salary，$8代表第二个instructor的属性salary。*/</p><p>Π$4(σ​$4&lt;$8(instructor×instructor))</p><p>如果一个二元运算需要区分其运算对象的两个关系，也可使用为指标及作为关系的名称。E.g. $R1指代第一个作为运算对象的关系，$R2指代第二个关系。</p><h5 id="附加的关系运算"><a href="#附加的关系运算" class="headerlink" title="附加的关系运算"></a>附加的关系运算</h5><p>这些运算都可以被基本的关系代数所替代</p><p><strong>集合交（intersection）运算</strong> (∩) r-(r-s)<br><strong>自然连接（natural join）运算</strong> (⋈)<br>属性名相同的进行合并<br><strong>theta连接（theta join）运算</strong>：是自然连接的扩展。<br>考虑关系r(R)和s(S)，θ是模式R∪S的属性上的谓词。r ⋈<sub>θ</sub> s = σ<sub>θ</sub>(r×s)<br><strong>赋值（assignment）运算</strong> (←) 把右值赋值给左边的临时变量<br><strong>外连接（outer-join）运算</strong>  左外连接（left outer join）(⟕) 右外连接（right outer join）(⟖) 全外链接（full outer join）(⟗)<br><strong>除法（Division operator）</strong><br>R(Sid,Cid)÷S(Cid)=T(Sid)<br>要求上式满足商与除数的笛卡尔积是在R中的<br><img src="/关系代数/5.2(2).jpg"></p><h5 id="拓展的关系代数"><a href="#拓展的关系代数" class="headerlink" title="拓展的关系代数"></a>拓展的关系代数</h5><p><strong>广义投影（generalized-projection）</strong></p><p>通过允许在投影列表使用算术运算和字符串函数等来对投影进行扩展。</p><p>e.g. 查询每个教师的ID、name、dept_name以及每月的工资</p><p>Π<sub>ID, name, dept_name, salary/12</sub>(instructor)</p><p><strong>聚集函数（aggregate function）</strong>：输入值的一个汇集，将单一值作为结果返回。</p><p>通式：</p><p><sub>G1, G2, …, Gn</sub>𝒢<sub> F1(A1), F2(A2), …, Fm(Am)</sub>(E)</p><p>e.g. 分别查询a. 每个系教师的平均工资 b. 所有教师的平均工资</p><p><sub>dept_name</sub> 𝒢 <sub>average(salary)</sub>(instructor)</p><p>𝒢 <sub>average(salary)</sub>(instructor)</p><img src="/关系代数/5.2(3).jpg"><h5 id="Modification-of-the-Database"><a href="#Modification-of-the-Database" class="headerlink" title="Modification of the Database"></a>Modification of the Database</h5><p><strong>Deletion</strong></p><p>Can delete only whole tuples;cannot delete values on only particular attributes</p><p>A deletion is expressed in relational algebra by:</p><p>r←r-E</p><p>where r is a relation and E is a relational algebra query.</p><p><strong>Insertion</strong></p><p>与上面类似</p><p>r←r∪E</p><p><strong>Updating</strong></p><p>A mechanism to change a value in a tuple without charging all values in the tuple</p><p>Use the generalized projection operator to do this task</p><p>r←Π<sub>F1,F2…Fn</sub>(R)</p><p>Each Fi is either </p><p>the ith attribute of r,if the ith attribute is not updated, or,</p><p>if the attribute is to be updated Fi  is an expression, involving only constants and the attributes of r,which gives the new value for the attribute</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;基本运算&quot;&gt;&lt;a href=&quot;#基本运算&quot; class=&quot;headerlink&quot; title=&quot;基本运算&quot;&gt;&lt;/a&gt;基本运算&lt;/h5&gt;&lt;p&gt;选择&lt;strong&gt;（Selection）&lt;/strong&gt;σ&lt;/p&gt;
&lt;p&gt;投影&lt;strong&gt;（Projection）&lt;/strong&gt;Π&lt;/p&gt;
&lt;p&gt;并&lt;strong&gt;（Union）&lt;/strong&gt;∪&lt;/p&gt;
&lt;p&gt;集合差&lt;strong&gt;（Difference）&lt;/strong&gt;-&lt;/p&gt;
&lt;p&gt;笛卡尔积&lt;strong&gt;（cartesian product）&lt;/strong&gt; x&lt;/p&gt;
&lt;p&gt;更名&lt;strong&gt;（rename）&lt;/strong&gt;ρ&lt;sub&gt;x&lt;/sub&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>第八章关系数据库设计</title>
    <link href="https://ecnudayun.coding.me/%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>https://ecnudayun.coding.me/第八章关系数据库设计/</id>
    <published>2018-04-25T11:19:11.000Z</published>
    <updated>2018-05-02T17:13:22.395Z</updated>
    
    <content type="html"><![CDATA[<p>DDL is 生产力</p><p><strong>好的数据库</strong></p><p>决定条件很多</p><p><strong>键</strong>（主键与候选键）</p><p>The key attributes uniquely identify the tuple.</p><p><strong>函数依赖</strong></p><p>函数依赖简单地说就是属性集A决定属性集B，则B依赖于属性A</p><p>若对每个元组对t1，t2 t1[α]=t2[α] 都有t1[β]=t2[β] 那么有 α–&gt;β</p><a id="more"></a><p><strong>完全依赖</strong> α的任意真子集α‘都是不满足 α’–&gt;β</p><p><strong>平凡的函数依赖</strong> 在所有的关系中都满足 比如a,b–&gt;a</p><p><strong>有损分解</strong> <strong>无损分解</strong></p><p>分解之后通过自然连接得到的关系与原来的相同就是有损</p><p><strong>无关属性Canonical Cover</strong></p><p>Example1:GivenF= {A—&gt;C, AB —&gt; C }</p><p>B is extraneousin AB —&gt; C because {A —&gt; C,AB—&gt;C }logically implies A —&gt; C(I.e.the result of dropping B from AB —&gt; C).</p><p>Example2: Given F = {A —&gt; C, AB —&gt; CD}</p><p>C is extraneousin AB —&gt; CD since AB —&gt; D can be inferred even after deleting C</p><p><strong>保持函数依赖</strong></p><p>第一种算法</p><p>A decompositionis dependency preserving, if</p><p> (F1 U F2 U … U Fn)+ = F+</p><p>第二种算法（看不懂这个操作）</p><p>result = awhile(changes to result) do for each Ri in the decomposition t = (result ∩ Ri)+ ∩ Ri</p><p>result = result U t</p><p>If resultcontains all attributes in b, then the functional dependency a-&gt;b ispreserved</p><p><strong>第一范式</strong></p><p>所有的属性都是原子的就是第一范式</p><p><strong>第二范式</strong></p><p>如果关系模式R是第一范式的，而且关系中每一个非主属性不<strong>部分</strong>依赖于主键，称R是第二范式的</p><p>例子</p><table><thead><tr><th><strong>组件 ID （主键）</strong></th><th><strong>价格</strong></th><th><strong>供应商ID （主键）</strong></th><th><strong>供应商名称</strong></th><th><strong>供应商住址</strong></th></tr></thead><tbody><tr><td>65</td><td>59.99</td><td>1</td><td>Stylized Parts</td><td>VA</td></tr><tr><td>73</td><td>20.00</td><td>1</td><td>Stylized Parts</td><td>VA</td></tr><tr><td>65</td><td>69.99</td><td>2</td><td>ACME Industries</td><td>CA</td></tr></tbody></table><p>供应商的名称和住址就只和供应商 ID 有关（部分依赖），这不匹配第二范式的原则</p><p>应该改成两张表 </p><p><strong>第三范式</strong></p><p>要求所有非键属性都<strong>只和</strong>候选键有相关性，也就是说非键属性之间应该是独立无关的</p><p>所有的依赖没有传递</p><p>Third conditionis a minimal relaxation of BCNF to ensure dependency preservation .</p><p><strong>BC范式</strong></p><p>能消除所有基于函数依赖可以发现的冗余</p><p>要求 F+中所有α–&gt;β的函数依赖</p><p>要么α是超键 要么是平凡的函数依赖</p><p><strong>正则覆盖 Canonical Cover</strong></p><p>Fc是F的正则覆盖，则F逻辑蕴涵Fc中的所有依赖， 并且Fc逻辑蕴涵F中的所有依赖</p><p>1.Fc中的任何函数依赖都不含无关属性2.Fc中的函数依赖的左半部分都是唯一的</p><p>算法：</p><p>使用合并 把a–&gt;b a–&gt;c的合成 a–&gt;bc</p><p>再把无关属性去掉</p><p><strong>闭包的算法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">result:=α;</span><br><span class="line"></span><br><span class="line">while(result发生变化)do</span><br><span class="line"></span><br><span class="line">for each 函数依赖β→γ in F do</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line"> if β包含于result then result:=result∪γ ;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>bc范式分解</strong></p><p>Suppose we have a schema R and a non-trivial dependency α-&gt;β causes a violation of BCNF. We decompose R into:</p><p>R1= (α U β)</p><p>R2= (R - ( β-α))</p><p><strong>Example</strong></p><p>instr_dept(ID,name,salary, dept_name, building, budget )</p><p>α =dept_name(not key)</p><p>β=building,budget</p><p>F:{dept_name–&gt;building,budget}</p><p>and inst_dept isreplaced by</p><p>R1= (α U β)= (dept_name,building, budget )</p><p>R2=(R - ( β- α))= ( ID, name, salary, dept_name )</p><p><strong>bcnf分解算法实现：</strong></p><p>输入：关系模式R及其函数依赖集F。</p><p>输出：R的一个无损联接分解，其中每一个子关系模式都满足F在其上投影的BCNF。</p><p>反复运用逐步分解定理，逐步分解关系模式R，</p><p>使得每次分解都具有无损联接性，而且</p><p>每次分解出来的子关系模式至少有一个是BCNF的，</p><p>即：</p><p>1）置初值ρ={R}；</p><p>2）检查ρ中的关系模式，如果均属BCNF，则转4）；</p><p>3）在ρ中找出不属于BCNF的关系模式S，那么必有X→A∈F+，（A不包含于X），且X不是S的关键字。因此XA不包含S的全部属性。把S分解为{S1，S2}，其中S1=XA，S2=(S-A)X，并以{S1，S2}代替ρ中的S，返回2）</p><p>4）终止分解，输出ρ。</p><p><strong>3nf分解 算法实现：</strong></p><p>输入：关系模式R及其上的最小函数依赖集F。</p><p>输出：R的保持函数依赖的分解，其中每一个关系模式是关于F在其上投影的<strong>3NF</strong>。</p><p>1)如果R中存在一些不在F中出现的属性，</p><p>则将它们单独构成一个关系模式，并从模式R中消去；</p><p>2)如果F中有一个函数依赖X→A，且XA=R，则R不用分解，算法终止；</p><p>3)对F中的每一个函数依赖X→A，构造一个关系模式XA。</p><p>如果X→A1,X→A2,…,X→An均属于F，则构造一个关系模式XA1A2…An。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DDL is 生产力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好的数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;决定条件很多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;键&lt;/strong&gt;（主键与候选键）&lt;/p&gt;
&lt;p&gt;The key attributes uniquely identify the tuple.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数依赖简单地说就是属性集A决定属性集B，则B依赖于属性A&lt;/p&gt;
&lt;p&gt;若对每个元组对t1，t2 t1[α]=t2[α] 都有t1[β]=t2[β] 那么有 α–&amp;gt;β&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库第七章er模型</title>
    <link href="https://ecnudayun.coding.me/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%83%E7%AB%A0er%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ecnudayun.coding.me/数据库第七章er模型/</id>
    <published>2018-04-24T23:54:58.000Z</published>
    <updated>2018-05-02T13:54:07.858Z</updated>
    
    <content type="html"><![CDATA[<p>30页还行吧，。</p><p>本章基本内容：实体集，联系集，属性，E-R图</p><a id="more"></a><h4 id="实体集"><a href="#实体集" class="headerlink" title="实体集"></a>实体集</h4><p>把每一类数据对象的个体称为实体。</p><p><strong>实体集</strong> 有相同属性的实体集合</p><p><strong>联系</strong> 多个实体间的互相关联</p><p><strong>联系集</strong> </p><p>是两个以上的实体集的数学关系</p><p>相同型联系的集合，参与联系集的实体的个数成为<strong>度</strong></p><p><strong>属性</strong> </p><p>简单属性 复合属性（可以划分成更小的属性）</p><p>单值属性 多值属性</p><p>派生属性 这个属性的值可以从其他的相关属性或实体派生出来</p><h4 id="映射基数"><a href="#映射基数" class="headerlink" title="映射基数"></a>映射基数</h4><p><em>一个实体</em>通过一个联系集能关联的<em>实体集</em>的个数</p><p>多指的是0个或多个</p><h5 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h5><p>直观的例子：</p><p>instructor中的属性<code>ID、name、dept_name、salary</code> <code>ID</code>是主码</p><p>department中的属性<code>dept_name、building、budget</code> <code>dept_name</code>是主码</p><p><code>dept_name</code>在两个实体集中都有出现，是department的主码，在instructor中应该删除</p><h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h4><p>联系集属性用未分割的矩形表示  用虚连将联系集和联系集的属性连到一起</p><p>双线表示实体集的全部参与</p><p>双菱形表示虚实体集的标志联系集</p><p>一对一 ：实体&lt;—–联系——&gt;实体</p><p>一对多：实体&lt;——联系——-实体</p><p>箭头指的地方是一</p><p>另一种表示可以具体指明上下界</p><p>实体  <u>l..h</u> 联系  一个实体参加到联系的关系是最少l最高h个的对应</p><p>复杂的属性用{}</p><p>角色：在菱形和矩形上的连线上标注来表示角色</p><p>每个非二元联系集中最多只能有一个箭头</p><p><strong>弱实体集</strong></p><p>没有主码的实体集为弱实体集</p><p>有主码的实体集为强实体集</p><p>弱实体集全部参与且多对一强实体集</p><p>弱实体集的分辨符虚线的下划线表示</p><h4 id="ER图转化为关系模式"><a href="#ER图转化为关系模式" class="headerlink" title="ER图转化为关系模式"></a>ER图转化为关系模式</h4><h5 id="强实体集的表示"><a href="#强实体集的表示" class="headerlink" title="强实体集的表示"></a>强实体集的表示</h5><p>将复合属性转化为多个叶子节点属性</p><p>多值属性建立新的关系模式</p><h5 id="弱实体集的表示"><a href="#弱实体集的表示" class="headerlink" title="弱实体集的表示"></a>弱实体集的表示</h5><p>弱实体集的分辨符加上所依赖的强实体集的主键</p><p>要标志好外键</p><p><strong>联系集</strong></p><p>多对多：将联系转化为<strong>关系模式</strong>，主键为两个实体集主码的并集</p><p>多对一：一的主码加到多的关系中</p><p>一对一：随便将一个的主码加到另一个中</p><h5 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h5><p>在实体集内部进行分组的过程称为特化</p><p>在ER图中用从特化实体指向另一个实体的空心箭头来表示</p><p>重叠特化（允许）用两个独立的空心箭头，不相交特化使用一个箭头</p><h5 id="概化"><a href="#概化" class="headerlink" title="概化"></a>概化</h5><p>特化的逆过程</p><p>er图中不做区分</p><h5 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h5><p>联系的联系，也就是联系间的联系</p><h5 id="概化转关系模式"><a href="#概化转关系模式" class="headerlink" title="概化转关系模式"></a>概化转关系模式</h5><p>有两种选择</p><p>第一种：高层实体集建一张表，低层的也建表，底层中把高层的主键作为外键</p><p>第二种：不要高层的表，把每个低层建表</p><h5 id="聚集的建表"><a href="#聚集的建表" class="headerlink" title="聚集的建表"></a>聚集的建表</h5><p>把联系集的主码并到一起（具体参考书上的例子）</p><p>本章感觉还是不是特别清晰……..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;30页还行吧，。&lt;/p&gt;
&lt;p&gt;本章基本内容：实体集，联系集，属性，E-R图&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库第四章基本不会....</title>
    <link href="https://ecnudayun.coding.me/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9F%BA%E6%9C%AC%E4%B8%8D%E4%BC%9A/"/>
    <id>https://ecnudayun.coding.me/数据库第四章基本不会/</id>
    <published>2018-04-24T14:32:56.000Z</published>
    <updated>2018-05-02T11:00:18.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中级sql"><a href="#中级sql" class="headerlink" title="中级sql"></a>中级sql</h3><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>第一种方式<code>A join B using（P1，P2...）</code>要求A，B都要有相同的属性名P1,P2…..</p><p>第二种方式<code>A join B on P</code>P和where语句的差不多的写法</p><p>这两种都是外连接<br><a id="more"></a></p><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p><code>left outer join</code> 左外连接：只保存运算中左边的关系的元组</p><p><code>right outer join</code>右外连接</p><p><code>full outer join</code>全外连接</p><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>虚关系并不预先运算出来，而是在使用的时候才通过执行查询被计算</p><p><code>create view v as &lt;query expression&gt;</code>as 里写的是视图要查询的东西</p><p>eg.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view faculty as </span><br><span class="line">select ID,name,dept_name</span><br><span class="line">from instroctor;</span><br></pre></td></tr></table></figure></p><p><strong>物化视图</strong>与通常的视图不一样，它存储着查询结果，并随着实际关系的改变而改变</p><p>书上写的一般不允许对视图进行修改</p><p>（可更新的）可修改的情况：</p><p>1.from 子句只有一个关系</p><p>2.select 子句只包含关系的属性名，不包含表达式，聚集函数，distinct</p><p>3.任何没有出现在select中的属性都允许为空值</p><p>4.查询中不包括group by 和having</p><p>满足这些限制的view可以进行update insert delete操作</p><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>transaction，应用层面的最小的工作单元</p><p>Commit work：提交当前事务，长久的保存在数据库中</p><p>Rollback work：回滚，就像是撤销编辑，如果突然断电将被回滚</p><p>在许多sql实现中，默认方式是每个sql语句自成一个事务，一执行，自动提交</p><h5 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h5><p>两种添加约束的方式：在create的时候申明，还有一种是通过<strong>alter table</strong> table-name <strong>add</strong> constraint</p><p>not null ， unique ， check子句</p><p><code>unique (Aj1,Aj2,Aj3,...,Ajn)</code> 表示Aj1,Aj2,Aj3,…,Ajn形成了一个候选码</p><p><code>check(P)</code>  P是一个谓词</p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table section(</span><br><span class="line">.....</span><br><span class="line">check (semester **in** (&apos;Fall&apos;,&apos;Spring&apos;,&apos;Winter&apos;,&apos;Summer&apos;) ) );</span><br></pre></td></tr></table></figure></p><p>foreign key</p><p><code>foreign key(dept_name)reference department</code> 建立外键</p><p>参照完整性约束：dept_name 的值必须是department关系中主码对应的属性有的</p><p>还有一种写法</p><p><code>dept_name varchar(20)references department</code></p><p><strong>当违反参照完整性约束时</strong></p><p>一般情况是拒绝</p><p>如果有其他声明则不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table course（...</span><br><span class="line">foreign key(dept_name)reference department</span><br><span class="line">on delete cascade</span><br><span class="line">on update cascade，</span><br><span class="line">...);</span><br></pre></td></tr></table></figure><p>因为<code>on delete cascade</code>在删除department中的元组导致此参照完整姓被破坏时，选择级联删除</p><p>因为<code>on update cascade</code>在更新的时候也是采用级联更新</p><p>还可以进行置为null的操作把cascade改为set null</p><hr><p>下面书上开始迷幻操作</p><h5 id="事务中对完整性约束的违反"><a href="#事务中对完整性约束的违反" class="headerlink" title="事务中对完整性约束的违反"></a>事务中对完整性约束的违反</h5><p>sql标准允许完整性约束的检查不是在事务的中间步骤检查而是在事务结束后检查（<strong>在许多数据库中不允许</strong>）</p><p>将initial deferred 子句加到约束声明中</p><h5 id="断言（？？？）"><a href="#断言（？？？）" class="headerlink" title="断言（？？？）"></a>断言（？？？）</h5><p>CREATE ASSERTION&lt;断言名&gt;</p><p>CHECK(&lt;条件&gt;)</p><hr><h4 id="sql中的数据类型与模式"><a href="#sql中的数据类型与模式" class="headerlink" title="sql中的数据类型与模式"></a>sql中的数据类型与模式</h4><h5 id="date"><a href="#date" class="headerlink" title="date"></a>date</h5><ul><li>DATE - 格式 YYYY-MM-DD</li><li>DATETIME - 格式: YYYY-MM-DD HH:MM:SS</li><li>TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS</li><li>YEAR - 格式 YYYY 或 YY</li></ul><p>时间范围<br>DATE– &gt; ‘1000-01-01’ to ‘9999-12-31’.<br>DATETIME –&gt; ‘1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’.<br>TIMESTAMP – &gt; ‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC</p><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>如<code>default null</code></p><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX 索引名称</span><br><span class="line">ON 表名称 (列名称)</span><br></pre></td></tr></table></figure><h5 id="用户定义的类型–独特类型"><a href="#用户定义的类型–独特类型" class="headerlink" title="用户定义的类型–独特类型"></a>用户定义的类型–独特类型</h5><p>用<code>create type</code>来定义新类型</p><p><strong>create type</strong> Dollars <strong>as numeric（ 12， 2 ）final</strong>； </p><p>用户定义类型Dollars订一位总共12位数字的十进制数，其中两位放在十进制小数点后。 </p><p>在此关键字final并不是真的有意义，SQL：1999标准要求的。 </p><p>例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table department( </span><br><span class="line">dept_name varchar(20), </span><br><span class="line">building varchar(15), </span><br><span class="line">budget Dollars );</span><br></pre></td></tr></table></figure><p><strong>drop type</strong>／<strong>alter type</strong>：删除／修改以前创建过的类型。</p><p><strong>create domain 可以定义一个域</strong> 域是可以声明约束的，并且域是可以可以赋值给另一个域，只要基本类型是相同的</p><h5 id="create-table的扩展"><a href="#create-table的扩展" class="headerlink" title="create table的扩展"></a>create table的扩展</h5><p><code>create table temp_instructor like instructor;</code>  创建一个与instructor模式相同的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t1 as</span><br><span class="line">(select *</span><br><span class="line">from instructor</span><br><span class="line">where dept_name=&apos;music&apos;)</span><br><span class="line">with data;</span><br></pre></td></tr></table></figure><h5 id="模式、目录与环境-看不懂溜了"><a href="#模式、目录与环境-看不懂溜了" class="headerlink" title="模式、目录与环境(看不懂溜了)"></a>模式、目录与环境(看不懂溜了)</h5><h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><p>权限列表为  select insert update delete  all privileges</p><p><strong>grant</strong> &lt; 权限列表 &gt;      //<strong>select  insert  update  delete</strong> </p><p><strong>on</strong> &lt; 关系名或视图名 &gt; </p><p><strong>to</strong> &lt; 用户 /角色列表 &gt;; </p><p>例：授予数据库用户Amit和Satoshi在department关系上的select权限： </p><p><strong>grant select on</strong> department <strong>to</strong> Amit, Satoshi；</p><p>收回revoke </p><p><strong>revoke</strong> &lt; 权限列表 &gt;     //<strong>select  insert  update  delete</strong> </p><p><strong>on</strong> &lt; 关系名或视图名 &gt; </p><p><strong>to</strong> &lt; 用户 /角色列表 &gt;; </p><p>例：收回数据库用户Amit和Satoshi在department关系上的budget属性上的更新权限： </p><p>revoke update ( budget ) on department from Amit, Satoshi；</p><h5 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h5><p>创建角色： <strong>create role</strong> instructor;</p><p>授予权限： </p><p><strong>grant select on</strong> takes </p><p><strong>to</strong> instructor;</p><p>用户或角色的权限： </p><p>所有直接授予用户／角色的权限； </p><p>所有授予给用户／角色所拥有角色的权限。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;中级sql&quot;&gt;&lt;a href=&quot;#中级sql&quot; class=&quot;headerlink&quot; title=&quot;中级sql&quot;&gt;&lt;/a&gt;中级sql&lt;/h3&gt;&lt;h5 id=&quot;内连接&quot;&gt;&lt;a href=&quot;#内连接&quot; class=&quot;headerlink&quot; title=&quot;内连接&quot;&gt;&lt;/a&gt;内连接&lt;/h5&gt;&lt;p&gt;第一种方式&lt;code&gt;A join B using（P1，P2...）&lt;/code&gt;要求A，B都要有相同的属性名P1,P2…..&lt;/p&gt;
&lt;p&gt;第二种方式&lt;code&gt;A join B on P&lt;/code&gt;P和where语句的差不多的写法&lt;/p&gt;
&lt;p&gt;这两种都是外连接&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库第三章复习</title>
    <link href="https://ecnudayun.coding.me/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://ecnudayun.coding.me/数据库第三章复习/</id>
    <published>2018-04-24T12:49:11.000Z</published>
    <updated>2018-05-02T11:09:44.162Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第三章-SQL不熟悉的地方"><a href="#第三章-SQL不熟悉的地方" class="headerlink" title="第三章  SQL不熟悉的地方"></a>第三章  SQL不熟悉的地方</h4><h5 id="聚集函数-avg，min，max，sum，count"><a href="#聚集函数-avg，min，max，sum，count" class="headerlink" title="聚集函数 avg，min，max，sum，count"></a>聚集函数 avg，min，max，sum，count</h5><ol><li>count函数是可以使用count（distinct 属性名）的</li><li>任何出现在group by中的属性，如果出现在select语句中，只能出现在聚集函数中（主要是数量上要相等，在mysql中实测不一定）</li><li>having子句在分组之后作用，因此可以在having中使用聚集函数</li><li>除了count（*），其他的聚集函数都是忽略null值的</li></ol><h5 id="exist结构用法："><a href="#exist结构用法：" class="headerlink" title="exist结构用法："></a>exist结构用法：</h5><p>后面非空的时候返回true</p><h5 id="unique结构："><a href="#unique结构：" class="headerlink" title="unique结构："></a>unique结构：</h5><p>不常用，查询结果没有重复的元组返回true</p><h5 id="with子句："><a href="#with子句：" class="headerlink" title="with子句："></a>with子句：</h5><a id="more"></a><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">with max_budget(value) as </span><br><span class="line"></span><br><span class="line">(select max(budget)</span><br><span class="line"></span><br><span class="line">from department)</span><br><span class="line"></span><br><span class="line">select budget</span><br><span class="line"></span><br><span class="line">from department,max_budget</span><br><span class="line"></span><br><span class="line">where department.budget = max_budget.value;</span><br></pre></td></tr></table></figure></p><h5 id="delete语句："><a href="#delete语句：" class="headerlink" title="delete语句："></a>delete语句：</h5><p>delete from r               r是表名</p><p>where P;                       P是对应的语句</p><h5 id="insert语句："><a href="#insert语句：" class="headerlink" title="insert语句："></a>insert语句：</h5><p>基本写法</p><p>insert into 表名【（可以选择具体的插入）】</p><p>​    values（，，，，，）</p><p>其他写法</p><p>insert into 表名</p><p>​    select查询语句</p><h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p>基本写法：</p><p>update 表名</p><p>set 语句</p><p>其他写法：</p><p>update 表名</p><p>set 属性名 = </p><p>case</p><p>​    when p then r</p><p>​    when p1 then r1</p><p>​    …..</p><p>​    else rn</p><p>end</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;第三章-SQL不熟悉的地方&quot;&gt;&lt;a href=&quot;#第三章-SQL不熟悉的地方&quot; class=&quot;headerlink&quot; title=&quot;第三章  SQL不熟悉的地方&quot;&gt;&lt;/a&gt;第三章  SQL不熟悉的地方&lt;/h4&gt;&lt;h5 id=&quot;聚集函数-avg，min，max，sum，count&quot;&gt;&lt;a href=&quot;#聚集函数-avg，min，max，sum，count&quot; class=&quot;headerlink&quot; title=&quot;聚集函数 avg，min，max，sum，count&quot;&gt;&lt;/a&gt;聚集函数 avg，min，max，sum，count&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;count函数是可以使用count（distinct 属性名）的&lt;/li&gt;
&lt;li&gt;任何出现在group by中的属性，如果出现在select语句中，只能出现在聚集函数中（主要是数量上要相等，在mysql中实测不一定）&lt;/li&gt;
&lt;li&gt;having子句在分组之后作用，因此可以在having中使用聚集函数&lt;/li&gt;
&lt;li&gt;除了count（*），其他的聚集函数都是忽略null值的&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;exist结构用法：&quot;&gt;&lt;a href=&quot;#exist结构用法：&quot; class=&quot;headerlink&quot; title=&quot;exist结构用法：&quot;&gt;&lt;/a&gt;exist结构用法：&lt;/h5&gt;&lt;p&gt;后面非空的时候返回true&lt;/p&gt;
&lt;h5 id=&quot;unique结构：&quot;&gt;&lt;a href=&quot;#unique结构：&quot; class=&quot;headerlink&quot; title=&quot;unique结构：&quot;&gt;&lt;/a&gt;unique结构：&lt;/h5&gt;&lt;p&gt;不常用，查询结果没有重复的元组返回true&lt;/p&gt;
&lt;h5 id=&quot;with子句：&quot;&gt;&lt;a href=&quot;#with子句：&quot; class=&quot;headerlink&quot; title=&quot;with子句：&quot;&gt;&lt;/a&gt;with子句：&lt;/h5&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>hexo插入图片</title>
    <link href="https://ecnudayun.coding.me/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>https://ecnudayun.coding.me/hexo插入图片/</id>
    <published>2018-04-24T01:21:10.000Z</published>
    <updated>2018-05-01T14:33:27.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo-插入图片操作比较奇怪，弄了很久"><a href="#hexo-插入图片操作比较奇怪，弄了很久" class="headerlink" title="hexo 插入图片操作比较奇怪，弄了很久"></a>hexo 插入图片操作比较奇怪，弄了很久</h3><p>这里写下成功的一种办法：<br>使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。<br>第二种：在public中的对应文件(和md的名字一样)中放入图片</p><p>这样的话会有个问题</p><p>在hexo clean命令之后public中的图片会被删掉</p><a id="more"></a><p>书写方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/hexo插入图片/初音.jpg&quot;&gt;</span><br></pre></td></tr></table></figure><br><img src="/hexo插入图片/初音.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;hexo-插入图片操作比较奇怪，弄了很久&quot;&gt;&lt;a href=&quot;#hexo-插入图片操作比较奇怪，弄了很久&quot; class=&quot;headerlink&quot; title=&quot;hexo 插入图片操作比较奇怪，弄了很久&quot;&gt;&lt;/a&gt;hexo 插入图片操作比较奇怪，弄了很久&lt;/h3&gt;&lt;p&gt;这里写下成功的一种办法：&lt;br&gt;使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。&lt;br&gt;第二种：在public中的对应文件(和md的名字一样)中放入图片&lt;/p&gt;
&lt;p&gt;这样的话会有个问题&lt;/p&gt;
&lt;p&gt;在hexo clean命令之后public中的图片会被删掉&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://ecnudayun.coding.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>jdbc插入数据</title>
    <link href="https://ecnudayun.coding.me/jdbc%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
    <id>https://ecnudayun.coding.me/jdbc插入数据/</id>
    <published>2018-04-23T15:32:00.000Z</published>
    <updated>2018-05-02T01:11:53.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="没错，我就是来凑日更的"><a href="#没错，我就是来凑日更的" class="headerlink" title="没错，我就是来凑日更的"></a>没错，我就是来凑日更的</h2><p>今天实现的内容异常简单，因为改坑爹的前段美化花了一点点时间；<br>晚上就只能简单的瞎搞搞了<br>首先写个静态的html用来读取用户名和密码<br><a id="more"></a><br>简单的尝试，主要还是熟悉下jdbc的一些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;hello world&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form name = &quot;login&quot; method=&quot;POST&quot; action=&quot;JDBC&quot;&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;div align=&quot;right&quot;&gt;Username:&lt;/div&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;div align=&quot;right&quot;&gt;Password:&lt;/div&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>不做任何检验，把读取的直接扔给servlet<br>servl在昨天的基础上加了一点点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class DatabaseAccess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/DatabaseAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletForJDBC</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用户的名字和密码</span></span><br><span class="line">    String username = <span class="string">""</span>;</span><br><span class="line">    String password = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//读取到名字密码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/booking"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"******"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"Servlet Mysql 测试"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动器</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 打开一个连接</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 执行 SQL 查询</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql1;</span><br><span class="line">            String sql2;</span><br><span class="line">            sql1 = <span class="string">"INSERT INTO people values (NULL,'"</span>+username+<span class="string">"','"</span>+password+<span class="string">"','',1)"</span>;</span><br><span class="line">            sql2 = <span class="string">"SELECT people_id, people_name, people_phone FROM people"</span>;</span><br><span class="line">            <span class="comment">//检验sql是不是写对了</span></span><br><span class="line">    System.out.print(sql1);</span><br><span class="line">            stmt.execute(sql1);</span><br><span class="line">            ResultSet rs2 = stmt.executeQuery(sql2);</span><br><span class="line">            <span class="comment">// 展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span>(rs2.next())&#123;</span><br><span class="line">                <span class="comment">// 通过字段检索</span></span><br><span class="line">                <span class="keyword">int</span> id  = rs2.getInt(<span class="string">"people_id"</span>);</span><br><span class="line">                String name = rs2.getString(<span class="string">"people_name"</span>);</span><br><span class="line">                String phone = rs2.getString(<span class="string">"people_phone"</span>);</span><br><span class="line">                <span class="comment">// 输出数据</span></span><br><span class="line">                out.println(<span class="string">"ID: "</span> + id);</span><br><span class="line">                out.println(<span class="string">", 名字: "</span> + name);</span><br><span class="line">                out.println(<span class="string">", 电话是: "</span> + phone);</span><br><span class="line">                out.println(<span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs2.close();</span><br><span class="line">    </span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException se) &#123;</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 最后是用于关闭资源的块</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                    stmt.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                    conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：数据库的名字是booking，为了完成期末的小项目，开始准备搞点东西<br>xml和昨天相同<br>结果如下</p><p><img src="/jdbc插入数据/4.23.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;没错，我就是来凑日更的&quot;&gt;&lt;a href=&quot;#没错，我就是来凑日更的&quot; class=&quot;headerlink&quot; title=&quot;没错，我就是来凑日更的&quot;&gt;&lt;/a&gt;没错，我就是来凑日更的&lt;/h2&gt;&lt;p&gt;今天实现的内容异常简单，因为改坑爹的前段美化花了一点点时间；&lt;br&gt;晚上就只能简单的瞎搞搞了&lt;br&gt;首先写个静态的html用来读取用户名和密码&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="selvlet" scheme="https://ecnudayun.coding.me/tags/selvlet/"/>
    
  </entry>
  
  <entry>
    <title>servlet通过jdbc访问数据库</title>
    <link href="https://ecnudayun.coding.me/servlet%E9%80%9A%E8%BF%87jdbc%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://ecnudayun.coding.me/servlet通过jdbc连接数据库/</id>
    <published>2018-04-22T12:39:00.000Z</published>
    <updated>2018-04-23T15:31:49.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文为菜鸡学习笔记"><a href="#本文为菜鸡学习笔记" class="headerlink" title="本文为菜鸡学习笔记"></a>本文为菜鸡学习笔记</h1><p>直接上代码吧，参考的菜鸟学习<br>注意要把<br>mysql-connector-java-5.1.38-bin.jar<br>放在WEB-INF下新建一个lib存放<br>servle 部分如下：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class DatabaseAccess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/DatabaseAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletForJDBC</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/数据库名称"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"Servlet Mysql 测试"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动器</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开一个连接</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行 SQL 查询</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql;</span><br><span class="line">            sql = <span class="string">"查询语句"</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="comment">// 通过字段检索</span></span><br><span class="line">                <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                String age = rs.getString(<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输出数据</span></span><br><span class="line">                out.println(<span class="string">"ID: "</span> + id);</span><br><span class="line">                out.println(<span class="string">", 名称: "</span> + name);</span><br><span class="line">                out.println(<span class="string">", 年龄："</span> + age);</span><br><span class="line">                out.println(<span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException se) &#123;</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 最后是用于关闭资源的块</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                    stmt.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                    conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就完成了连接jdbc并且查询的功能的servlet部分<br>然后配置好xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;JDBC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;mypack.ServletForJDBC&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;JDBC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/JDBC&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文为菜鸡学习笔记&quot;&gt;&lt;a href=&quot;#本文为菜鸡学习笔记&quot; class=&quot;headerlink&quot; title=&quot;本文为菜鸡学习笔记&quot;&gt;&lt;/a&gt;本文为菜鸡学习笔记&lt;/h1&gt;&lt;p&gt;直接上代码吧，参考的菜鸟学习&lt;br&gt;注意要把&lt;br&gt;mysql-connector-java-5.1.38-bin.jar&lt;br&gt;放在WEB-INF下新建一个lib存放&lt;br&gt;servle 部分如下：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="selvlet" scheme="https://ecnudayun.coding.me/tags/selvlet/"/>
    
  </entry>
  
  <entry>
    <title>blog建设</title>
    <link href="https://ecnudayun.coding.me/Blog%E5%BB%BA%E8%AE%BE/"/>
    <id>https://ecnudayun.coding.me/Blog建设/</id>
    <published>2018-04-22T12:20:00.000Z</published>
    <updated>2018-04-22T15:53:12.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="blog大致完工"><a href="#blog大致完工" class="headerlink" title="blog大致完工"></a>blog大致完工</h1><p>各种操作尚未熟练，blog的外观问题改日再弄，先学一波操作，每日更新（假装日更）<br>貌似这玩意被我当日记本了？还是笔记本？<br>也 不 care</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;blog大致完工&quot;&gt;&lt;a href=&quot;#blog大致完工&quot; class=&quot;headerlink&quot; title=&quot;blog大致完工&quot;&gt;&lt;/a&gt;blog大致完工&lt;/h1&gt;&lt;p&gt;各种操作尚未熟练，blog的外观问题改日再弄，先学一波操作，每日更新（假装日更）&lt;br&gt;貌似
      
    
    </summary>
    
    
  </entry>
  
</feed>
