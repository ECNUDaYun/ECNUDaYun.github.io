<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云之学习之路</title>
  
  <subtitle>追寻着丢失的气球...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ecnudayun.coding.me/"/>
  <updated>2018-05-05T13:42:53.734Z</updated>
  <id>https://ecnudayun.coding.me/</id>
  
  <author>
    <name>Da yun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>凑日更之python语法篇</title>
    <link href="https://ecnudayun.coding.me/%E5%87%91%E6%97%A5%E6%9B%B4%E4%B9%8Bpython%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    <id>https://ecnudayun.coding.me/凑日更之python语法篇/</id>
    <published>2018-05-05T01:35:17.000Z</published>
    <updated>2018-05-05T13:42:53.734Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅作为对某些（主要用来凑更）语法知识的回顾与复习，面向百度书（xia）写</p><p>适合 <del>所有人</del> 本来就知道这些的人观看</p><h4 id="基本规范"><a href="#基本规范" class="headerlink" title="基本规范"></a>基本规范</h4><h5 id="基础编码编码"><a href="#基础编码编码" class="headerlink" title="基础编码编码"></a>基础编码编码</h5><p>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码</p><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p><code>#</code>用来注释</p><p>多行的注释可以选择多个<code>#</code>或者</p><p>使用<code>&#39;&#39;&#39;</code>或者<code>&quot;&quot;&quot;</code>来注释</p><a id="more"></a><h5 id="代码基本输入"><a href="#代码基本输入" class="headerlink" title="代码基本输入"></a>代码基本输入</h5><p>一般的教程可能没写</p><p>用手指一个一个按，对的</p><p>python有个很人xing的设计，行末没有<code>;</code></p><p>这个设计很棒可以增大键盘上 向右键 的寿命；</p><p>一行如果想弄多个语句，比如想把10行代码弄到一行，ok，用；分割他们</p><p><strong>空行</strong></p><p>python3语法中对空行没有要求，空行仅仅是对程序员友好的一种工具</p><h5 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h5><p>当你输入的时候某些原因你把好好的一句代码弄成多行</p><p>python3的编译器表示不认识</p><p>这个时候使用一手<code>()</code> <code>[]</code> <code>{}</code></p><p>或者用下面这种写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>多行的字符串用三引号</p><p>看例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s=&apos;&apos;&apos;</span><br><span class="line">sada</span><br><span class="line">asdas</span><br><span class="line">asda</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&apos;\nsada\nasdas\nasda\n&apos;</span><br></pre></td></tr></table></figure><h5 id="应用模块"><a href="#应用模块" class="headerlink" title="应用模块"></a>应用模块</h5><p>python中应用的是模块，不是炉石中的那个模块</p><p>模块是.py文件</p><p>多个.py文件构成包</p><p><code>import &lt;包名或者模块名（这个表述不是很准确）&gt;</code>和<code>from &lt;&gt; import &lt;&gt;</code></p><p>&lt;&gt;中写的东西我还不是特别清楚索性不写，基本用法知道会用就行</p><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p>python3中很皮</p><h5 id="简单写下整数浮点数问题"><a href="#简单写下整数浮点数问题" class="headerlink" title="简单写下整数浮点数问题"></a>简单写下整数浮点数问题</h5><p>整数与浮点数运算会得到浮点数的结果</p><p>除法（重点）一定得到浮点数 即使结果是真实的计算结果是整数，python3给你的结果也是整数.0</p><p><code>//</code>表示取整除法 两个整数进行这个操作的时候得到的是整数</p><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p><code>and not or</code>  这个不能写成<code>&amp;&amp; ！ ||</code>  这个设定很不舒服</p><p>所以表示一个数a是偶数的装逼写法在python中的书写就感觉很low</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if not a&amp;1:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="迭代器和生成器（先了解下这个再看基本数据结构）"><a href="#迭代器和生成器（先了解下这个再看基本数据结构）" class="headerlink" title="迭代器和生成器（先了解下这个再看基本数据结构）"></a>迭代器和生成器（先了解下这个再看基本数据结构）</h4><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><p>我仿佛记得老师说list是迭代器</p><p>但shell告诉我它不是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list=[1,2,3,4]</span><br><span class="line">&gt;&gt;&gt; next(list)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#26&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(list)</span><br><span class="line">TypeError: &apos;list&apos; object is not an iterator</span><br><span class="line">&gt;&gt;&gt; it=iter(list)</span><br><span class="line">&gt;&gt;&gt; next(it)</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>虽然他不是但使用上有一定的相似处，都可以使用for进行迭代，但实现方式其实不太一样</p><p>迭代器的主要的两个函数就是使用<code>iter()</code> ,<code>next()</code></p><p>iter方法是python的一个内建方法，它会返回一个<strong>迭代器对象</strong></p><h5 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h5><p>这个东东用到的机会有点少，抽象的介绍下</p><p>使用了 yield 的函数被称为生成器（generator），生成器是一个<strong>返回迭代器</strong>的函数，只能用于迭代操作</p><h5 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h5><p><strong>range()函数</strong></p><p>在python2中，这东西返回的还是一个list</p><p>Python3 range() 函数返回的是一个<strong>可迭代对象</strong>（注意和前面iter生成的迭代器对象有区别）</p><p>它也是不能使用next()函数的</p><p>这个时候敏锐的朋友可能猜到，其实字符串，元组，列表，字典也是可迭代对象</p><p>可以实现for遍历的都是可迭代对象</p><p>顺手把for遍历写了，开心</p><p>先来最不同寻常的，字典的遍历</p><p>看下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d=&#123;&apos;python&apos;:1,&apos;php&apos;:2,&apos;java&apos;:3&#125;</span><br><span class="line">&gt;&gt;&gt; d.keys()</span><br><span class="line">dict_keys([&apos;python&apos;, &apos;php&apos;, &apos;java&apos;])</span><br><span class="line">&gt;&gt;&gt; d.values()</span><br><span class="line">dict_values([1, 2, 3])</span><br><span class="line">&gt;&gt;&gt; d.items()</span><br><span class="line">dict_items([(&apos;python&apos;, 1), (&apos;php&apos;, 2), (&apos;java&apos;, 3)])</span><br></pre></td></tr></table></figure><p>因为字典中有两个值，一个key值，一个是value值，所以在遍历的时候会有些不太一样的地方，直接遍历得到的是遍历的是key</p><p>自定义的遍历，可以对d.keys()和d.values()和d.items() （这几个返回的都是<strong>可迭代对象</strong>，和list的相似度比较高，但是我试了下，他们不能进行下标访问）进行遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#for key in d.keys():</span><br><span class="line">#for value in d.values():</span><br><span class="line">#for k , v in d.items():</span><br></pre></td></tr></table></figure><p>注：（下面这段不是很必要的操作）</p><p>enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。返回一个<strong>枚举对象</strong>而且这个对象是可以迭代的</p><h4 id="几个自带的常用的数据结构"><a href="#几个自带的常用的数据结构" class="headerlink" title="几个自带的常用的数据结构"></a>几个自带的常用的数据结构</h4><p>字符串，元组，列表，字典，集合</p><p>但是我并不想按顺序写，毕竟看这个的人都是本来就会的人/滑稽</p><p>相同点：</p><p>1.他们都是可迭代对象具体见上面一部分</p><p>2.len()这个函数可以返回字符串、列表、字典、元组、集合等的长度</p><p>官方文档令人信服：</p><blockquote><p>Return the length (the number of items) of an object. The argument may be a<br>sequence (such as a string, bytes, tuple, list, or range) or a collection (such<br>as a dictionary, set, or frozen set).</p></blockquote><p>3.list()实测可以对这几种数据结构进行转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(1)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#307&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    list(1)</span><br><span class="line">TypeError: &apos;int&apos; object is not iterable</span><br></pre></td></tr></table></figure><p>我们可以看到只要是可迭代的就可以实现list()函数，实现的效果就是用for遍历出来，然后再打个包价格[]一样</p><p>set() tuple()都是一样的，他们的效果都是差不多的，set操作之后可能顺序不太一样，因为set是无序的</p><p>他们都可以对<strong>可迭代对象</strong>进行操作</p><p>4.str() 把所有的的都加上“”，与list()不同，它对参数不进行任何处理直接加””，简单粗暴，注意对本来是字符串的它不处理</p><p>repr()更粗暴，连string类的都加引号</p><p>5.tuple()和list()做的是差不多的事</p><p>对字典操作的时返回的是key值</p><p>对字符串返回的是分开的一个个字符串与list的结果相似</p><p>6.<code>+</code> 操作要求相同的数据结构</p><p> <code>+=</code> 居然不一样，还好我试了一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a=&quot;abc&quot;</span><br><span class="line">&gt;&gt;&gt; b=(1,2,3)</span><br><span class="line">&gt;&gt;&gt; c=[4,5,6]</span><br><span class="line">&gt;&gt;&gt; d=&#123;1,2,3&#125;</span><br><span class="line">&gt;&gt;&gt; e=&#123;1:&quot;a&quot;,2:&quot;b&quot;&#125;</span><br></pre></td></tr></table></figure><p>经过测试</p><p>任意两个相加是报错的</p><p>但是！！！！(还好<strong>意外只有一个)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c+=a</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[4, 5, 6, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&gt;&gt;&gt; c+=b</span><br><span class="line">&gt;&gt;&gt; c+=d</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[4, 5, 6, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; c+=e</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[4, 5, 6, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 1, 2, 3, 1, 2, 3, 1, 2]</span><br></pre></td></tr></table></figure><p>列表实现了自己独特的<u>运算符重载</u> ，在加字典的时候加的是key值</p><p>其实很简单，肉眼能看出来，他们仿佛就是使用了下list()函数之后再相加（当然我是猜的，我没看具体实现方式）</p><p>7.<code>*</code> 相当于自己加起来</p><p>相同点差不多就这几点吧</p><p>下面的几点相似度稍微低一点</p><h5 id="support-indexing-（就是用中括号来制定索引）"><a href="#support-indexing-（就是用中括号来制定索引）" class="headerlink" title="support indexing （就是用中括号来制定索引）"></a>support indexing （就是用中括号来制定索引）</h5><p>实测结果，字符串，元组，列表， 字典都有</p><p>其中，string，tuple，list的用法都是相同的</p><p>以list的例子来表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list=[&quot;abc&quot;,234,&#123;2,3&#125;]</span><br><span class="line">&gt;&gt;&gt; list</span><br><span class="line">[&apos;abc&apos;, 234, &#123;2, 3&#125;]</span><br><span class="line">&gt;&gt;&gt; list[]</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line">&gt;&gt;&gt; list[:]</span><br><span class="line">[&apos;abc&apos;, 234, &#123;2, 3&#125;]</span><br><span class="line">&gt;&gt;&gt; list[::2]</span><br><span class="line">[&apos;abc&apos;, &#123;2, 3&#125;]</span><br></pre></td></tr></table></figure><p>字典的话是使用hash的方式来寻值的</p><p>例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&apos;python&apos;: 1, &apos;php&apos;: 2, &apos;java&apos;: 3&#125;</span><br><span class="line">&gt;&gt;&gt; d[:]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#109&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d[:]</span><br><span class="line">TypeError: unhashable type: &apos;slice&apos;</span><br><span class="line">&gt;&gt;&gt; d[1]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#110&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d[1]</span><br><span class="line">KeyError: 1</span><br><span class="line">&gt;&gt;&gt; d[&quot;python&quot;]</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h5 id="id号"><a href="#id号" class="headerlink" title="id号"></a>id号</h5><p>string和元组内容是不可变的</p><p>他们两个的所有的方法是不改变对象本身的</p><p>在id号这件事上我们区别对待</p><p>取string和list进行对比</p><p>string</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s=&quot;abcd&quot;</span><br><span class="line">&gt;&gt;&gt; s1=s</span><br><span class="line">&gt;&gt;&gt; id(s)==id(s1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; s+=&quot;d&quot;</span><br><span class="line">&gt;&gt;&gt; id(s)==id(s1)</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; id([1,2,3])</span><br><span class="line">58631072</span><br><span class="line">&gt;&gt;&gt; l=[1,2,3]</span><br><span class="line">&gt;&gt;&gt; id(l)</span><br><span class="line">58630992</span><br><span class="line">&gt;&gt;&gt; l1=l</span><br><span class="line">&gt;&gt;&gt; id(l)==id(l1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; l.append(4)</span><br><span class="line">&gt;&gt;&gt; id(l)</span><br><span class="line">58630992</span><br><span class="line">&gt;&gt;&gt; id(l1)</span><br><span class="line">58630992</span><br><span class="line">&gt;&gt;&gt; l1</span><br><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>具体这是怎么实现的先不管</p><p>我们可以从现象观察到</p><p>1.在最初赋值阶段，变量的id与真正写成“abc”和[1,2,3]的id其实是不同的</p><p>2.但是他们用<code>=</code>进行赋值给其他的变量的时候，其实是把id给人家了，string不可变，所以在改值的时候是用<code>=</code>重新给值了，所以改后的id变了，所以值和原来的不一样；</p><p>list是可变的，对象没变的，操作的是同一个对象，所以id号没变</p><h5 id="修改对象"><a href="#修改对象" class="headerlink" title="修改对象"></a>修改对象</h5><p>string和tuple就只能=进行复制来修改了</p><p><strong>增加</strong>：</p><p><strong>list</strong>通方法<code>append(obj)</code></p><p>注意这个里面是放的object，直接把对象扔到list里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c=[1,2]</span><br><span class="line">&gt;&gt;&gt; c.append(range(0,4))</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">[1, 2, range(0, 4)]</span><br></pre></td></tr></table></figure><p><strong>set</strong>通过<code>add()</code>方法，加的结果是去重的</p><p>字典的比较不同，看下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;&#125;</span><br><span class="line">&gt;&gt;&gt; e[3]=&apos;c&apos;</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文仅作为对某些（主要用来凑更）语法知识的回顾与复习，面向百度书（xia）写&lt;/p&gt;
&lt;p&gt;适合 &lt;del&gt;所有人&lt;/del&gt; 本来就知道这些的人观看&lt;/p&gt;
&lt;h4 id=&quot;基本规范&quot;&gt;&lt;a href=&quot;#基本规范&quot; class=&quot;headerlink&quot; title=&quot;基本规范&quot;&gt;&lt;/a&gt;基本规范&lt;/h4&gt;&lt;h5 id=&quot;基础编码编码&quot;&gt;&lt;a href=&quot;#基础编码编码&quot; class=&quot;headerlink&quot; title=&quot;基础编码编码&quot;&gt;&lt;/a&gt;基础编码编码&lt;/h5&gt;&lt;p&gt;默认情况下，Python 3 源码文件以 &lt;strong&gt;UTF-8&lt;/strong&gt; 编码&lt;/p&gt;
&lt;h5 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h5&gt;&lt;p&gt;&lt;code&gt;#&lt;/code&gt;用来注释&lt;/p&gt;
&lt;p&gt;多行的注释可以选择多个&lt;code&gt;#&lt;/code&gt;或者&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;&amp;#39;&amp;#39;&amp;#39;&lt;/code&gt;或者&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;来注释&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://ecnudayun.coding.me/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>关系模式介绍</title>
    <link href="https://ecnudayun.coding.me/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D/"/>
    <id>https://ecnudayun.coding.me/关系模式介绍/</id>
    <published>2018-05-02T10:48:21.000Z</published>
    <updated>2018-05-02T11:03:56.175Z</updated>
    
    <content type="html"><![CDATA[<p>本章的类容偏概览，当时学的时候理解的很差，后面的知识学了一些之后再看书好很多</p><h5 id="relation-schema-关系模式"><a href="#relation-schema-关系模式" class="headerlink" title="relation schema 关系模式"></a>relation schema 关系模式</h5><p>一般来说关系模式是 由属性序列及各属性对应域组成</p><h5 id="superkey"><a href="#superkey" class="headerlink" title="superkey"></a>superkey</h5><p>唯一的标识一个元组</p><h5 id="候选码"><a href="#候选码" class="headerlink" title="候选码"></a>候选码</h5><p>最小的超码 可以有很多个</p><h5 id="主码"><a href="#主码" class="headerlink" title="主码"></a>主码</h5><p>主要的候选码</p><h5 id="码"><a href="#码" class="headerlink" title="码"></a>码</h5><p>它包括超码，候选码，主码。</p><h5 id="关系查询语言"><a href="#关系查询语言" class="headerlink" title="关系查询语言"></a>关系查询语言</h5><p>过程化 非过程化</p><p>关系代数是过程化的</p><p>元组关系演算和域关系演算是非过程化的（这个貌似没讲也没看）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本章的类容偏概览，当时学的时候理解的很差，后面的知识学了一些之后再看书好很多&lt;/p&gt;
&lt;h5 id=&quot;relation-schema-关系模式&quot;&gt;&lt;a href=&quot;#relation-schema-关系模式&quot; class=&quot;headerlink&quot; title=&quot;relati
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关系代数</title>
    <link href="https://ecnudayun.coding.me/%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"/>
    <id>https://ecnudayun.coding.me/关系代数/</id>
    <published>2018-05-01T14:31:54.000Z</published>
    <updated>2018-05-02T03:31:02.545Z</updated>
    
    <content type="html"><![CDATA[<h5 id="基本运算"><a href="#基本运算" class="headerlink" title="基本运算"></a>基本运算</h5><p>选择<strong>（Selection）</strong>σ</p><p>投影<strong>（Projection）</strong>Π</p><p>并<strong>（Union）</strong>∪</p><p>集合差<strong>（Difference）</strong>-</p><p>笛卡尔积<strong>（cartesian product）</strong> x</p><p>更名<strong>（rename）</strong>ρ<sub>x</sub></p><a id="more"></a><p>1.选择</p><p>用小写sigma(σ)表示，下标为谓词，括号中为参数关系</p><p>σ<sub>dept_name</sub>=”Physics”(instructor)</p><img src="/关系代数/5.2(1).jpg"><p>2.投影</p><p>返回作为参数的关系，但把某些属性排除在外，所有重复行均被去除。用大写pi(Π)表示，下标为在结果中出现的属性，括号中为参数关系。</p><p>投影操作会去掉重复</p><p>3.并运算</p><p>可将两个集合并起来，找出出现在两个集合之一或同时出现在两个集合中的所有元组。用∪表示。</p><p>要满足两个条件才能进行运算</p><p>a. r,s must have the same arity  (same number of attributes)</p><p>b. The attribute domains must be compatible</p><p>4.集合差</p><p>表达式r-s包含所有在r中而不在s中的元组的关系。</p><p>要满足两个条件才能进行运算</p><p>a. r,s must have the same arity  (same number of attributes)</p><p>b. The attribute domains must be compatible</p><p>5.笛卡尔积</p><p>将任意两个关系的信息组合在一起，结果中包含所有可能的元组对。</p><p>由于相同的属性名可能同时出现在r1和r2中，需要一个命名机制来区别这些属性。可采用把属性所来自的关系名称附加到该属性上的方法。</p><p>笛卡尔积运算参数的关系名称必须不同。</p><p>6.更名操作</p><p>给关系代数表达式的结果赋上名字以供引用，用小写rho(ρ)表示。</p><p>更名运算的另一形式：ρx(A1, A2, …, An)(E)。假设关系代数表达式E是n元的，运算返回表达式E的结果，并把名字x赋给它，同时将各属性更名为A1, A2, …, An。</p><p>e.g. 找出大学里的最高工资</p><p>/*步骤1：计算出一个由非最高工资组成的临时关系。</p><p>首先通过更名运算引用其中一个instructor关系以便计算笛卡尔积instructor×instructor，再构造选择运算比较任意两个出现在同一元组中的salary选择较低的元组。通过投影选取instructor.salary列得到非最高工资构成的临时关系*/</p><p>Πinstructor.salary (σinstructor.salary&lt;d.salary(instructor×ρd(instructor)))</p><p>/*步骤2：计算关系Πsalary (instructor)和刚才计算出的非最高工资构成的临时关系的集合差，</p><p>得到结果。*/</p><p>Πsalary (instructor)-Πinstructor.salary (σinstructor.salary&lt;d.salary(instructor×ρd(instructor)))</p><p>更名运算不是必须的，因为可以用<strong>位置标记</strong>隐含地作为关系（或关系代数表达式运算的结果）的属性名，用$1、$2、…指代第一个属性、第二个属性…以此类推。</p><p>e.g. 用位置标记来计算大学里的非最高工资构成的临时关系</p><p>/*在笛卡尔积(instructor×instructor)中，</p><p>$4代表第一个instructor的属性salary，$8代表第二个instructor的属性salary。*/</p><p>Π$4(σ​$4&lt;$8(instructor×instructor))</p><p>如果一个二元运算需要区分其运算对象的两个关系，也可使用为指标及作为关系的名称。E.g. $R1指代第一个作为运算对象的关系，$R2指代第二个关系。</p><h5 id="附加的关系运算"><a href="#附加的关系运算" class="headerlink" title="附加的关系运算"></a>附加的关系运算</h5><p>这些运算都可以被基本的关系代数所替代</p><p><strong>集合交（intersection）运算</strong> (∩) r-(r-s)<br><strong>自然连接（natural join）运算</strong> (⋈)<br>属性名相同的进行合并<br><strong>theta连接（theta join）运算</strong>：是自然连接的扩展。<br>考虑关系r(R)和s(S)，θ是模式R∪S的属性上的谓词。r ⋈<sub>θ</sub> s = σ<sub>θ</sub>(r×s)<br><strong>赋值（assignment）运算</strong> (←) 把右值赋值给左边的临时变量<br><strong>外连接（outer-join）运算</strong>  左外连接（left outer join）(⟕) 右外连接（right outer join）(⟖) 全外链接（full outer join）(⟗)<br><strong>除法（Division operator）</strong><br>R(Sid,Cid)÷S(Cid)=T(Sid)<br>要求上式满足商与除数的笛卡尔积是在R中的<br><img src="/关系代数/5.2(2).jpg"></p><h5 id="拓展的关系代数"><a href="#拓展的关系代数" class="headerlink" title="拓展的关系代数"></a>拓展的关系代数</h5><p><strong>广义投影（generalized-projection）</strong></p><p>通过允许在投影列表使用算术运算和字符串函数等来对投影进行扩展。</p><p>e.g. 查询每个教师的ID、name、dept_name以及每月的工资</p><p>Π<sub>ID, name, dept_name, salary/12</sub>(instructor)</p><p><strong>聚集函数（aggregate function）</strong>：输入值的一个汇集，将单一值作为结果返回。</p><p>通式：</p><p><sub>G1, G2, …, Gn</sub>𝒢<sub> F1(A1), F2(A2), …, Fm(Am)</sub>(E)</p><p>e.g. 分别查询a. 每个系教师的平均工资 b. 所有教师的平均工资</p><p><sub>dept_name</sub> 𝒢 <sub>average(salary)</sub>(instructor)</p><p>𝒢 <sub>average(salary)</sub>(instructor)</p><img src="/关系代数/5.2(3).jpg"><h5 id="Modification-of-the-Database"><a href="#Modification-of-the-Database" class="headerlink" title="Modification of the Database"></a>Modification of the Database</h5><p><strong>Deletion</strong></p><p>Can delete only whole tuples;cannot delete values on only particular attributes</p><p>A deletion is expressed in relational algebra by:</p><p>r←r-E</p><p>where r is a relation and E is a relational algebra query.</p><p><strong>Insertion</strong></p><p>与上面类似</p><p>r←r∪E</p><p><strong>Updating</strong></p><p>A mechanism to change a value in a tuple without charging all values in the tuple</p><p>Use the generalized projection operator to do this task</p><p>r←Π<sub>F1,F2…Fn</sub>(R)</p><p>Each Fi is either </p><p>the ith attribute of r,if the ith attribute is not updated, or,</p><p>if the attribute is to be updated Fi  is an expression, involving only constants and the attributes of r,which gives the new value for the attribute</p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;基本运算&quot;&gt;&lt;a href=&quot;#基本运算&quot; class=&quot;headerlink&quot; title=&quot;基本运算&quot;&gt;&lt;/a&gt;基本运算&lt;/h5&gt;&lt;p&gt;选择&lt;strong&gt;（Selection）&lt;/strong&gt;σ&lt;/p&gt;
&lt;p&gt;投影&lt;strong&gt;（Projection）&lt;/strong&gt;Π&lt;/p&gt;
&lt;p&gt;并&lt;strong&gt;（Union）&lt;/strong&gt;∪&lt;/p&gt;
&lt;p&gt;集合差&lt;strong&gt;（Difference）&lt;/strong&gt;-&lt;/p&gt;
&lt;p&gt;笛卡尔积&lt;strong&gt;（cartesian product）&lt;/strong&gt; x&lt;/p&gt;
&lt;p&gt;更名&lt;strong&gt;（rename）&lt;/strong&gt;ρ&lt;sub&gt;x&lt;/sub&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>第八章关系数据库设计</title>
    <link href="https://ecnudayun.coding.me/%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"/>
    <id>https://ecnudayun.coding.me/第八章关系数据库设计/</id>
    <published>2018-04-25T11:19:11.000Z</published>
    <updated>2018-05-02T17:13:22.395Z</updated>
    
    <content type="html"><![CDATA[<p>DDL is 生产力</p><p><strong>好的数据库</strong></p><p>决定条件很多</p><p><strong>键</strong>（主键与候选键）</p><p>The key attributes uniquely identify the tuple.</p><p><strong>函数依赖</strong></p><p>函数依赖简单地说就是属性集A决定属性集B，则B依赖于属性A</p><p>若对每个元组对t1，t2 t1[α]=t2[α] 都有t1[β]=t2[β] 那么有 α–&gt;β</p><a id="more"></a><p><strong>完全依赖</strong> α的任意真子集α‘都是不满足 α’–&gt;β</p><p><strong>平凡的函数依赖</strong> 在所有的关系中都满足 比如a,b–&gt;a</p><p><strong>有损分解</strong> <strong>无损分解</strong></p><p>分解之后通过自然连接得到的关系与原来的相同就是有损</p><p><strong>无关属性Canonical Cover</strong></p><p>Example1:GivenF= {A—&gt;C, AB —&gt; C }</p><p>B is extraneousin AB —&gt; C because {A —&gt; C,AB—&gt;C }logically implies A —&gt; C(I.e.the result of dropping B from AB —&gt; C).</p><p>Example2: Given F = {A —&gt; C, AB —&gt; CD}</p><p>C is extraneousin AB —&gt; CD since AB —&gt; D can be inferred even after deleting C</p><p><strong>保持函数依赖</strong></p><p>第一种算法</p><p>A decompositionis dependency preserving, if</p><p> (F1 U F2 U … U Fn)+ = F+</p><p>第二种算法（看不懂这个操作）</p><p>result = awhile(changes to result) do for each Ri in the decomposition t = (result ∩ Ri)+ ∩ Ri</p><p>result = result U t</p><p>If resultcontains all attributes in b, then the functional dependency a-&gt;b ispreserved</p><p><strong>第一范式</strong></p><p>所有的属性都是原子的就是第一范式</p><p><strong>第二范式</strong></p><p>如果关系模式R是第一范式的，而且关系中每一个非主属性不<strong>部分</strong>依赖于主键，称R是第二范式的</p><p>例子</p><table><thead><tr><th><strong>组件 ID （主键）</strong></th><th><strong>价格</strong></th><th><strong>供应商ID （主键）</strong></th><th><strong>供应商名称</strong></th><th><strong>供应商住址</strong></th></tr></thead><tbody><tr><td>65</td><td>59.99</td><td>1</td><td>Stylized Parts</td><td>VA</td></tr><tr><td>73</td><td>20.00</td><td>1</td><td>Stylized Parts</td><td>VA</td></tr><tr><td>65</td><td>69.99</td><td>2</td><td>ACME Industries</td><td>CA</td></tr></tbody></table><p>供应商的名称和住址就只和供应商 ID 有关（部分依赖），这不匹配第二范式的原则</p><p>应该改成两张表 </p><p><strong>第三范式</strong></p><p>要求所有非键属性都<strong>只和</strong>候选键有相关性，也就是说非键属性之间应该是独立无关的</p><p>所有的依赖没有传递</p><p>Third conditionis a minimal relaxation of BCNF to ensure dependency preservation .</p><p><strong>BC范式</strong></p><p>能消除所有基于函数依赖可以发现的冗余</p><p>要求 F+中所有α–&gt;β的函数依赖</p><p>要么α是超键 要么是平凡的函数依赖</p><p><strong>正则覆盖 Canonical Cover</strong></p><p>Fc是F的正则覆盖，则F逻辑蕴涵Fc中的所有依赖， 并且Fc逻辑蕴涵F中的所有依赖</p><p>1.Fc中的任何函数依赖都不含无关属性2.Fc中的函数依赖的左半部分都是唯一的</p><p>算法：</p><p>使用合并 把a–&gt;b a–&gt;c的合成 a–&gt;bc</p><p>再把无关属性去掉</p><p><strong>闭包的算法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">result:=α;</span><br><span class="line"></span><br><span class="line">while(result发生变化)do</span><br><span class="line"></span><br><span class="line">for each 函数依赖β→γ in F do</span><br><span class="line"></span><br><span class="line">begin</span><br><span class="line"></span><br><span class="line"> if β包含于result then result:=result∪γ ;</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>bc范式分解</strong></p><p>Suppose we have a schema R and a non-trivial dependency α-&gt;β causes a violation of BCNF. We decompose R into:</p><p>R1= (α U β)</p><p>R2= (R - ( β-α))</p><p><strong>Example</strong></p><p>instr_dept(ID,name,salary, dept_name, building, budget )</p><p>α =dept_name(not key)</p><p>β=building,budget</p><p>F:{dept_name–&gt;building,budget}</p><p>and inst_dept isreplaced by</p><p>R1= (α U β)= (dept_name,building, budget )</p><p>R2=(R - ( β- α))= ( ID, name, salary, dept_name )</p><p><strong>bcnf分解算法实现：</strong></p><p>输入：关系模式R及其函数依赖集F。</p><p>输出：R的一个无损联接分解，其中每一个子关系模式都满足F在其上投影的BCNF。</p><p>反复运用逐步分解定理，逐步分解关系模式R，</p><p>使得每次分解都具有无损联接性，而且</p><p>每次分解出来的子关系模式至少有一个是BCNF的，</p><p>即：</p><p>1）置初值ρ={R}；</p><p>2）检查ρ中的关系模式，如果均属BCNF，则转4）；</p><p>3）在ρ中找出不属于BCNF的关系模式S，那么必有X→A∈F+，（A不包含于X），且X不是S的关键字。因此XA不包含S的全部属性。把S分解为{S1，S2}，其中S1=XA，S2=(S-A)X，并以{S1，S2}代替ρ中的S，返回2）</p><p>4）终止分解，输出ρ。</p><p><strong>3nf分解 算法实现：</strong></p><p>输入：关系模式R及其上的最小函数依赖集F。</p><p>输出：R的保持函数依赖的分解，其中每一个关系模式是关于F在其上投影的<strong>3NF</strong>。</p><p>1)如果R中存在一些不在F中出现的属性，</p><p>则将它们单独构成一个关系模式，并从模式R中消去；</p><p>2)如果F中有一个函数依赖X→A，且XA=R，则R不用分解，算法终止；</p><p>3)对F中的每一个函数依赖X→A，构造一个关系模式XA。</p><p>如果X→A1,X→A2,…,X→An均属于F，则构造一个关系模式XA1A2…An。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DDL is 生产力&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好的数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;决定条件很多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;键&lt;/strong&gt;（主键与候选键）&lt;/p&gt;
&lt;p&gt;The key attributes uniquely identify the tuple.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数依赖简单地说就是属性集A决定属性集B，则B依赖于属性A&lt;/p&gt;
&lt;p&gt;若对每个元组对t1，t2 t1[α]=t2[α] 都有t1[β]=t2[β] 那么有 α–&amp;gt;β&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库第七章er模型</title>
    <link href="https://ecnudayun.coding.me/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%83%E7%AB%A0er%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ecnudayun.coding.me/数据库第七章er模型/</id>
    <published>2018-04-24T23:54:58.000Z</published>
    <updated>2018-05-02T13:54:07.858Z</updated>
    
    <content type="html"><![CDATA[<p>30页还行吧，。</p><p>本章基本内容：实体集，联系集，属性，E-R图</p><a id="more"></a><h4 id="实体集"><a href="#实体集" class="headerlink" title="实体集"></a>实体集</h4><p>把每一类数据对象的个体称为实体。</p><p><strong>实体集</strong> 有相同属性的实体集合</p><p><strong>联系</strong> 多个实体间的互相关联</p><p><strong>联系集</strong> </p><p>是两个以上的实体集的数学关系</p><p>相同型联系的集合，参与联系集的实体的个数成为<strong>度</strong></p><p><strong>属性</strong> </p><p>简单属性 复合属性（可以划分成更小的属性）</p><p>单值属性 多值属性</p><p>派生属性 这个属性的值可以从其他的相关属性或实体派生出来</p><h4 id="映射基数"><a href="#映射基数" class="headerlink" title="映射基数"></a>映射基数</h4><p><em>一个实体</em>通过一个联系集能关联的<em>实体集</em>的个数</p><p>多指的是0个或多个</p><h5 id="冗余"><a href="#冗余" class="headerlink" title="冗余"></a>冗余</h5><p>直观的例子：</p><p>instructor中的属性<code>ID、name、dept_name、salary</code> <code>ID</code>是主码</p><p>department中的属性<code>dept_name、building、budget</code> <code>dept_name</code>是主码</p><p><code>dept_name</code>在两个实体集中都有出现，是department的主码，在instructor中应该删除</p><h4 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h4><p>联系集属性用未分割的矩形表示  用虚连将联系集和联系集的属性连到一起</p><p>双线表示实体集的全部参与</p><p>双菱形表示虚实体集的标志联系集</p><p>一对一 ：实体&lt;—–联系——&gt;实体</p><p>一对多：实体&lt;——联系——-实体</p><p>箭头指的地方是一</p><p>另一种表示可以具体指明上下界</p><p>实体  <u>l..h</u> 联系  一个实体参加到联系的关系是最少l最高h个的对应</p><p>复杂的属性用{}</p><p>角色：在菱形和矩形上的连线上标注来表示角色</p><p>每个非二元联系集中最多只能有一个箭头</p><p><strong>弱实体集</strong></p><p>没有主码的实体集为弱实体集</p><p>有主码的实体集为强实体集</p><p>弱实体集全部参与且多对一强实体集</p><p>弱实体集的分辨符虚线的下划线表示</p><h4 id="ER图转化为关系模式"><a href="#ER图转化为关系模式" class="headerlink" title="ER图转化为关系模式"></a>ER图转化为关系模式</h4><h5 id="强实体集的表示"><a href="#强实体集的表示" class="headerlink" title="强实体集的表示"></a>强实体集的表示</h5><p>将复合属性转化为多个叶子节点属性</p><p>多值属性建立新的关系模式</p><h5 id="弱实体集的表示"><a href="#弱实体集的表示" class="headerlink" title="弱实体集的表示"></a>弱实体集的表示</h5><p>弱实体集的分辨符加上所依赖的强实体集的主键</p><p>要标志好外键</p><p><strong>联系集</strong></p><p>多对多：将联系转化为<strong>关系模式</strong>，主键为两个实体集主码的并集</p><p>多对一：一的主码加到多的关系中</p><p>一对一：随便将一个的主码加到另一个中</p><h5 id="特化"><a href="#特化" class="headerlink" title="特化"></a>特化</h5><p>在实体集内部进行分组的过程称为特化</p><p>在ER图中用从特化实体指向另一个实体的空心箭头来表示</p><p>重叠特化（允许）用两个独立的空心箭头，不相交特化使用一个箭头</p><h5 id="概化"><a href="#概化" class="headerlink" title="概化"></a>概化</h5><p>特化的逆过程</p><p>er图中不做区分</p><h5 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h5><p>联系的联系，也就是联系间的联系</p><h5 id="概化转关系模式"><a href="#概化转关系模式" class="headerlink" title="概化转关系模式"></a>概化转关系模式</h5><p>有两种选择</p><p>第一种：高层实体集建一张表，低层的也建表，底层中把高层的主键作为外键</p><p>第二种：不要高层的表，把每个低层建表</p><h5 id="聚集的建表"><a href="#聚集的建表" class="headerlink" title="聚集的建表"></a>聚集的建表</h5><p>把联系集的主码并到一起（具体参考书上的例子）</p><p>本章感觉还是不是特别清晰……..</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;30页还行吧，。&lt;/p&gt;
&lt;p&gt;本章基本内容：实体集，联系集，属性，E-R图&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库第四章基本不会....</title>
    <link href="https://ecnudayun.coding.me/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%9F%BA%E6%9C%AC%E4%B8%8D%E4%BC%9A/"/>
    <id>https://ecnudayun.coding.me/数据库第四章基本不会/</id>
    <published>2018-04-24T14:32:56.000Z</published>
    <updated>2018-05-02T11:00:18.765Z</updated>
    
    <content type="html"><![CDATA[<h3 id="中级sql"><a href="#中级sql" class="headerlink" title="中级sql"></a>中级sql</h3><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>第一种方式<code>A join B using（P1，P2...）</code>要求A，B都要有相同的属性名P1,P2…..</p><p>第二种方式<code>A join B on P</code>P和where语句的差不多的写法</p><p>这两种都是外连接<br><a id="more"></a></p><h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><p><code>left outer join</code> 左外连接：只保存运算中左边的关系的元组</p><p><code>right outer join</code>右外连接</p><p><code>full outer join</code>全外连接</p><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>虚关系并不预先运算出来，而是在使用的时候才通过执行查询被计算</p><p><code>create view v as &lt;query expression&gt;</code>as 里写的是视图要查询的东西</p><p>eg.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view faculty as </span><br><span class="line">select ID,name,dept_name</span><br><span class="line">from instroctor;</span><br></pre></td></tr></table></figure></p><p><strong>物化视图</strong>与通常的视图不一样，它存储着查询结果，并随着实际关系的改变而改变</p><p>书上写的一般不允许对视图进行修改</p><p>（可更新的）可修改的情况：</p><p>1.from 子句只有一个关系</p><p>2.select 子句只包含关系的属性名，不包含表达式，聚集函数，distinct</p><p>3.任何没有出现在select中的属性都允许为空值</p><p>4.查询中不包括group by 和having</p><p>满足这些限制的view可以进行update insert delete操作</p><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>transaction，应用层面的最小的工作单元</p><p>Commit work：提交当前事务，长久的保存在数据库中</p><p>Rollback work：回滚，就像是撤销编辑，如果突然断电将被回滚</p><p>在许多sql实现中，默认方式是每个sql语句自成一个事务，一执行，自动提交</p><h5 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h5><p>两种添加约束的方式：在create的时候申明，还有一种是通过<strong>alter table</strong> table-name <strong>add</strong> constraint</p><p>not null ， unique ， check子句</p><p><code>unique (Aj1,Aj2,Aj3,...,Ajn)</code> 表示Aj1,Aj2,Aj3,…,Ajn形成了一个候选码</p><p><code>check(P)</code>  P是一个谓词</p><p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table section(</span><br><span class="line">.....</span><br><span class="line">check (semester **in** (&apos;Fall&apos;,&apos;Spring&apos;,&apos;Winter&apos;,&apos;Summer&apos;) ) );</span><br></pre></td></tr></table></figure></p><p>foreign key</p><p><code>foreign key(dept_name)reference department</code> 建立外键</p><p>参照完整性约束：dept_name 的值必须是department关系中主码对应的属性有的</p><p>还有一种写法</p><p><code>dept_name varchar(20)references department</code></p><p><strong>当违反参照完整性约束时</strong></p><p>一般情况是拒绝</p><p>如果有其他声明则不同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table course（...</span><br><span class="line">foreign key(dept_name)reference department</span><br><span class="line">on delete cascade</span><br><span class="line">on update cascade，</span><br><span class="line">...);</span><br></pre></td></tr></table></figure><p>因为<code>on delete cascade</code>在删除department中的元组导致此参照完整姓被破坏时，选择级联删除</p><p>因为<code>on update cascade</code>在更新的时候也是采用级联更新</p><p>还可以进行置为null的操作把cascade改为set null</p><hr><p>下面书上开始迷幻操作</p><h5 id="事务中对完整性约束的违反"><a href="#事务中对完整性约束的违反" class="headerlink" title="事务中对完整性约束的违反"></a>事务中对完整性约束的违反</h5><p>sql标准允许完整性约束的检查不是在事务的中间步骤检查而是在事务结束后检查（<strong>在许多数据库中不允许</strong>）</p><p>将initial deferred 子句加到约束声明中</p><h5 id="断言（？？？）"><a href="#断言（？？？）" class="headerlink" title="断言（？？？）"></a>断言（？？？）</h5><p>CREATE ASSERTION&lt;断言名&gt;</p><p>CHECK(&lt;条件&gt;)</p><hr><h4 id="sql中的数据类型与模式"><a href="#sql中的数据类型与模式" class="headerlink" title="sql中的数据类型与模式"></a>sql中的数据类型与模式</h4><h5 id="date"><a href="#date" class="headerlink" title="date"></a>date</h5><ul><li>DATE - 格式 YYYY-MM-DD</li><li>DATETIME - 格式: YYYY-MM-DD HH:MM:SS</li><li>TIMESTAMP - 格式: YYYY-MM-DD HH:MM:SS</li><li>YEAR - 格式 YYYY 或 YY</li></ul><p>时间范围<br>DATE– &gt; ‘1000-01-01’ to ‘9999-12-31’.<br>DATETIME –&gt; ‘1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’.<br>TIMESTAMP – &gt; ‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC</p><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>如<code>default null</code></p><h5 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX 索引名称</span><br><span class="line">ON 表名称 (列名称)</span><br></pre></td></tr></table></figure><h5 id="用户定义的类型–独特类型"><a href="#用户定义的类型–独特类型" class="headerlink" title="用户定义的类型–独特类型"></a>用户定义的类型–独特类型</h5><p>用<code>create type</code>来定义新类型</p><p><strong>create type</strong> Dollars <strong>as numeric（ 12， 2 ）final</strong>； </p><p>用户定义类型Dollars订一位总共12位数字的十进制数，其中两位放在十进制小数点后。 </p><p>在此关键字final并不是真的有意义，SQL：1999标准要求的。 </p><p>例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table department( </span><br><span class="line">dept_name varchar(20), </span><br><span class="line">building varchar(15), </span><br><span class="line">budget Dollars );</span><br></pre></td></tr></table></figure><p><strong>drop type</strong>／<strong>alter type</strong>：删除／修改以前创建过的类型。</p><p><strong>create domain 可以定义一个域</strong> 域是可以声明约束的，并且域是可以可以赋值给另一个域，只要基本类型是相同的</p><h5 id="create-table的扩展"><a href="#create-table的扩展" class="headerlink" title="create table的扩展"></a>create table的扩展</h5><p><code>create table temp_instructor like instructor;</code>  创建一个与instructor模式相同的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t1 as</span><br><span class="line">(select *</span><br><span class="line">from instructor</span><br><span class="line">where dept_name=&apos;music&apos;)</span><br><span class="line">with data;</span><br></pre></td></tr></table></figure><h5 id="模式、目录与环境-看不懂溜了"><a href="#模式、目录与环境-看不懂溜了" class="headerlink" title="模式、目录与环境(看不懂溜了)"></a>模式、目录与环境(看不懂溜了)</h5><h5 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h5><p>权限列表为  select insert update delete  all privileges</p><p><strong>grant</strong> &lt; 权限列表 &gt;      //<strong>select  insert  update  delete</strong> </p><p><strong>on</strong> &lt; 关系名或视图名 &gt; </p><p><strong>to</strong> &lt; 用户 /角色列表 &gt;; </p><p>例：授予数据库用户Amit和Satoshi在department关系上的select权限： </p><p><strong>grant select on</strong> department <strong>to</strong> Amit, Satoshi；</p><p>收回revoke </p><p><strong>revoke</strong> &lt; 权限列表 &gt;     //<strong>select  insert  update  delete</strong> </p><p><strong>on</strong> &lt; 关系名或视图名 &gt; </p><p><strong>to</strong> &lt; 用户 /角色列表 &gt;; </p><p>例：收回数据库用户Amit和Satoshi在department关系上的budget属性上的更新权限： </p><p>revoke update ( budget ) on department from Amit, Satoshi；</p><h5 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h5><p>创建角色： <strong>create role</strong> instructor;</p><p>授予权限： </p><p><strong>grant select on</strong> takes </p><p><strong>to</strong> instructor;</p><p>用户或角色的权限： </p><p>所有直接授予用户／角色的权限； </p><p>所有授予给用户／角色所拥有角色的权限。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;中级sql&quot;&gt;&lt;a href=&quot;#中级sql&quot; class=&quot;headerlink&quot; title=&quot;中级sql&quot;&gt;&lt;/a&gt;中级sql&lt;/h3&gt;&lt;h5 id=&quot;内连接&quot;&gt;&lt;a href=&quot;#内连接&quot; class=&quot;headerlink&quot; title=&quot;内连接&quot;&gt;&lt;/a&gt;内连接&lt;/h5&gt;&lt;p&gt;第一种方式&lt;code&gt;A join B using（P1，P2...）&lt;/code&gt;要求A，B都要有相同的属性名P1,P2…..&lt;/p&gt;
&lt;p&gt;第二种方式&lt;code&gt;A join B on P&lt;/code&gt;P和where语句的差不多的写法&lt;/p&gt;
&lt;p&gt;这两种都是外连接&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库第三章复习</title>
    <link href="https://ecnudayun.coding.me/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%A4%8D%E4%B9%A0/"/>
    <id>https://ecnudayun.coding.me/数据库第三章复习/</id>
    <published>2018-04-24T12:49:11.000Z</published>
    <updated>2018-05-02T11:09:44.162Z</updated>
    
    <content type="html"><![CDATA[<h4 id="第三章-SQL不熟悉的地方"><a href="#第三章-SQL不熟悉的地方" class="headerlink" title="第三章  SQL不熟悉的地方"></a>第三章  SQL不熟悉的地方</h4><h5 id="聚集函数-avg，min，max，sum，count"><a href="#聚集函数-avg，min，max，sum，count" class="headerlink" title="聚集函数 avg，min，max，sum，count"></a>聚集函数 avg，min，max，sum，count</h5><ol><li>count函数是可以使用count（distinct 属性名）的</li><li>任何出现在group by中的属性，如果出现在select语句中，只能出现在聚集函数中（主要是数量上要相等，在mysql中实测不一定）</li><li>having子句在分组之后作用，因此可以在having中使用聚集函数</li><li>除了count（*），其他的聚集函数都是忽略null值的</li></ol><h5 id="exist结构用法："><a href="#exist结构用法：" class="headerlink" title="exist结构用法："></a>exist结构用法：</h5><p>后面非空的时候返回true</p><h5 id="unique结构："><a href="#unique结构：" class="headerlink" title="unique结构："></a>unique结构：</h5><p>不常用，查询结果没有重复的元组返回true</p><h5 id="with子句："><a href="#with子句：" class="headerlink" title="with子句："></a>with子句：</h5><a id="more"></a><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">with max_budget(value) as </span><br><span class="line"></span><br><span class="line">(select max(budget)</span><br><span class="line"></span><br><span class="line">from department)</span><br><span class="line"></span><br><span class="line">select budget</span><br><span class="line"></span><br><span class="line">from department,max_budget</span><br><span class="line"></span><br><span class="line">where department.budget = max_budget.value;</span><br></pre></td></tr></table></figure></p><h5 id="delete语句："><a href="#delete语句：" class="headerlink" title="delete语句："></a>delete语句：</h5><p>delete from r               r是表名</p><p>where P;                       P是对应的语句</p><h5 id="insert语句："><a href="#insert语句：" class="headerlink" title="insert语句："></a>insert语句：</h5><p>基本写法</p><p>insert into 表名【（可以选择具体的插入）】</p><p>​    values（，，，，，）</p><p>其他写法</p><p>insert into 表名</p><p>​    select查询语句</p><h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><p>基本写法：</p><p>update 表名</p><p>set 语句</p><p>其他写法：</p><p>update 表名</p><p>set 属性名 = </p><p>case</p><p>​    when p then r</p><p>​    when p1 then r1</p><p>​    …..</p><p>​    else rn</p><p>end</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;第三章-SQL不熟悉的地方&quot;&gt;&lt;a href=&quot;#第三章-SQL不熟悉的地方&quot; class=&quot;headerlink&quot; title=&quot;第三章  SQL不熟悉的地方&quot;&gt;&lt;/a&gt;第三章  SQL不熟悉的地方&lt;/h4&gt;&lt;h5 id=&quot;聚集函数-avg，min，max，sum，count&quot;&gt;&lt;a href=&quot;#聚集函数-avg，min，max，sum，count&quot; class=&quot;headerlink&quot; title=&quot;聚集函数 avg，min，max，sum，count&quot;&gt;&lt;/a&gt;聚集函数 avg，min，max，sum，count&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;count函数是可以使用count（distinct 属性名）的&lt;/li&gt;
&lt;li&gt;任何出现在group by中的属性，如果出现在select语句中，只能出现在聚集函数中（主要是数量上要相等，在mysql中实测不一定）&lt;/li&gt;
&lt;li&gt;having子句在分组之后作用，因此可以在having中使用聚集函数&lt;/li&gt;
&lt;li&gt;除了count（*），其他的聚集函数都是忽略null值的&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&quot;exist结构用法：&quot;&gt;&lt;a href=&quot;#exist结构用法：&quot; class=&quot;headerlink&quot; title=&quot;exist结构用法：&quot;&gt;&lt;/a&gt;exist结构用法：&lt;/h5&gt;&lt;p&gt;后面非空的时候返回true&lt;/p&gt;
&lt;h5 id=&quot;unique结构：&quot;&gt;&lt;a href=&quot;#unique结构：&quot; class=&quot;headerlink&quot; title=&quot;unique结构：&quot;&gt;&lt;/a&gt;unique结构：&lt;/h5&gt;&lt;p&gt;不常用，查询结果没有重复的元组返回true&lt;/p&gt;
&lt;h5 id=&quot;with子句：&quot;&gt;&lt;a href=&quot;#with子句：&quot; class=&quot;headerlink&quot; title=&quot;with子句：&quot;&gt;&lt;/a&gt;with子句：&lt;/h5&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://ecnudayun.coding.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>hexo插入图片</title>
    <link href="https://ecnudayun.coding.me/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/hexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"/>
    <id>https://ecnudayun.coding.me/hexo插入图片/hexo插入图片/</id>
    <published>2018-04-24T01:21:10.000Z</published>
    <updated>2018-05-01T14:33:27.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo-插入图片操作比较奇怪，弄了很久"><a href="#hexo-插入图片操作比较奇怪，弄了很久" class="headerlink" title="hexo 插入图片操作比较奇怪，弄了很久"></a>hexo 插入图片操作比较奇怪，弄了很久</h3><p>这里写下成功的一种办法：<br>使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。<br>第二种：在public中的对应文件(和md的名字一样)中放入图片</p><p>这样的话会有个问题</p><p>在hexo clean命令之后public中的图片会被删掉</p><a id="more"></a><p>书写方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/hexo插入图片/初音.jpg&quot;&gt;</span><br></pre></td></tr></table></figure><br><img src="/hexo插入图片/hexo插入图片/初音.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;hexo-插入图片操作比较奇怪，弄了很久&quot;&gt;&lt;a href=&quot;#hexo-插入图片操作比较奇怪，弄了很久&quot; class=&quot;headerlink&quot; title=&quot;hexo 插入图片操作比较奇怪，弄了很久&quot;&gt;&lt;/a&gt;hexo 插入图片操作比较奇怪，弄了很久&lt;/h3&gt;&lt;p&gt;这里写下成功的一种办法：&lt;br&gt;使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。&lt;br&gt;第二种：在public中的对应文件(和md的名字一样)中放入图片&lt;/p&gt;
&lt;p&gt;这样的话会有个问题&lt;/p&gt;
&lt;p&gt;在hexo clean命令之后public中的图片会被删掉&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://ecnudayun.coding.me/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>jdbc插入数据</title>
    <link href="https://ecnudayun.coding.me/jdbc%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/jdbc%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
    <id>https://ecnudayun.coding.me/jdbc插入数据/jdbc插入数据/</id>
    <published>2018-04-23T15:32:00.000Z</published>
    <updated>2018-05-02T01:11:53.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="没错，我就是来凑日更的"><a href="#没错，我就是来凑日更的" class="headerlink" title="没错，我就是来凑日更的"></a>没错，我就是来凑日更的</h2><p>今天实现的内容异常简单，因为改坑爹的前段美化花了一点点时间；<br>晚上就只能简单的瞎搞搞了<br>首先写个静态的html用来读取用户名和密码<br><a id="more"></a><br>简单的尝试，主要还是熟悉下jdbc的一些操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;hello world&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form name = &quot;login&quot; method=&quot;POST&quot; action=&quot;JDBC&quot;&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;div align=&quot;right&quot;&gt;Username:&lt;/div&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;div align=&quot;right&quot;&gt;Password:&lt;/div&gt;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;submit&quot;&gt;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p>不做任何检验，把读取的直接扔给servlet<br>servl在昨天的基础上加了一点点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class DatabaseAccess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/DatabaseAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletForJDBC</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用户的名字和密码</span></span><br><span class="line">    String username = <span class="string">""</span>;</span><br><span class="line">    String password = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//读取到名字密码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/booking"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"******"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        request.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        username = request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"Servlet Mysql 测试"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动器</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 打开一个连接</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 执行 SQL 查询</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql1;</span><br><span class="line">            String sql2;</span><br><span class="line">            sql1 = <span class="string">"INSERT INTO people values (NULL,'"</span>+username+<span class="string">"','"</span>+password+<span class="string">"','',1)"</span>;</span><br><span class="line">            sql2 = <span class="string">"SELECT people_id, people_name, people_phone FROM people"</span>;</span><br><span class="line">            <span class="comment">//检验sql是不是写对了</span></span><br><span class="line">    System.out.print(sql1);</span><br><span class="line">            stmt.execute(sql1);</span><br><span class="line">            ResultSet rs2 = stmt.executeQuery(sql2);</span><br><span class="line">            <span class="comment">// 展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span>(rs2.next())&#123;</span><br><span class="line">                <span class="comment">// 通过字段检索</span></span><br><span class="line">                <span class="keyword">int</span> id  = rs2.getInt(<span class="string">"people_id"</span>);</span><br><span class="line">                String name = rs2.getString(<span class="string">"people_name"</span>);</span><br><span class="line">                String phone = rs2.getString(<span class="string">"people_phone"</span>);</span><br><span class="line">                <span class="comment">// 输出数据</span></span><br><span class="line">                out.println(<span class="string">"ID: "</span> + id);</span><br><span class="line">                out.println(<span class="string">", 名字: "</span> + name);</span><br><span class="line">                out.println(<span class="string">", 电话是: "</span> + phone);</span><br><span class="line">                out.println(<span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs2.close();</span><br><span class="line">    </span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException se) &#123;</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 最后是用于关闭资源的块</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                    stmt.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                    conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：数据库的名字是booking，为了完成期末的小项目，开始准备搞点东西<br>xml和昨天相同<br>结果如下</p><p><img src="/jdbc插入数据/jdbc插入数据/4.23.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;没错，我就是来凑日更的&quot;&gt;&lt;a href=&quot;#没错，我就是来凑日更的&quot; class=&quot;headerlink&quot; title=&quot;没错，我就是来凑日更的&quot;&gt;&lt;/a&gt;没错，我就是来凑日更的&lt;/h2&gt;&lt;p&gt;今天实现的内容异常简单，因为改坑爹的前段美化花了一点点时间；&lt;br&gt;晚上就只能简单的瞎搞搞了&lt;br&gt;首先写个静态的html用来读取用户名和密码&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="selvlet" scheme="https://ecnudayun.coding.me/tags/selvlet/"/>
    
  </entry>
  
  <entry>
    <title>servlet通过jdbc访问数据库</title>
    <link href="https://ecnudayun.coding.me/servlet%E9%80%9A%E8%BF%87jdbc%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://ecnudayun.coding.me/servlet通过jdbc连接数据库/</id>
    <published>2018-04-22T12:39:00.000Z</published>
    <updated>2018-04-23T15:31:49.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本文为菜鸡学习笔记"><a href="#本文为菜鸡学习笔记" class="headerlink" title="本文为菜鸡学习笔记"></a>本文为菜鸡学习笔记</h1><p>直接上代码吧，参考的菜鸟学习<br>注意要把<br>mysql-connector-java-5.1.38-bin.jar<br>放在WEB-INF下新建一个lib存放<br>servle 部分如下：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mypack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class DatabaseAccess</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/DatabaseAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletForJDBC</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="comment">// JDBC 驱动名及数据库 URL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/数据库名称"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 设置响应内容类型</span></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        PrintWriter out = response.getWriter();</span><br><span class="line">        String title = <span class="string">"Servlet Mysql 测试"</span>;</span><br><span class="line">        String docType = <span class="string">"&lt;!DOCTYPE html&gt;\n"</span>;</span><br><span class="line">        out.println(docType +</span><br><span class="line">                <span class="string">"&lt;html&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;head&gt;&lt;title&gt;"</span> + title + <span class="string">"&lt;/title&gt;&lt;/head&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;body bgcolor=\"#f0f0f0\"&gt;\n"</span> +</span><br><span class="line">                <span class="string">"&lt;h1 align=\"center\"&gt;"</span> + title + <span class="string">"&lt;/h1&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动器</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打开一个连接</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行 SQL 查询</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql;</span><br><span class="line">            sql = <span class="string">"查询语句"</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="comment">// 通过字段检索</span></span><br><span class="line">                <span class="keyword">int</span> id  = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">                String age = rs.getString(<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 输出数据</span></span><br><span class="line">                out.println(<span class="string">"ID: "</span> + id);</span><br><span class="line">                out.println(<span class="string">", 名称: "</span> + name);</span><br><span class="line">                out.println(<span class="string">", 年龄："</span> + age);</span><br><span class="line">                out.println(<span class="string">"&lt;br /&gt;"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(<span class="string">"&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(SQLException se) &#123;</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 最后是用于关闭资源的块</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>)</span><br><span class="line">                    stmt.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="keyword">null</span>)</span><br><span class="line">                    conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就完成了连接jdbc并且查询的功能的servlet部分<br>然后配置好xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;JDBC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;mypack.ServletForJDBC&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;JDBC&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/JDBC&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;本文为菜鸡学习笔记&quot;&gt;&lt;a href=&quot;#本文为菜鸡学习笔记&quot; class=&quot;headerlink&quot; title=&quot;本文为菜鸡学习笔记&quot;&gt;&lt;/a&gt;本文为菜鸡学习笔记&lt;/h1&gt;&lt;p&gt;直接上代码吧，参考的菜鸟学习&lt;br&gt;注意要把&lt;br&gt;mysql-connector-java-5.1.38-bin.jar&lt;br&gt;放在WEB-INF下新建一个lib存放&lt;br&gt;servle 部分如下：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="selvlet" scheme="https://ecnudayun.coding.me/tags/selvlet/"/>
    
  </entry>
  
  <entry>
    <title>blog建设</title>
    <link href="https://ecnudayun.coding.me/Blog%E5%BB%BA%E8%AE%BE/"/>
    <id>https://ecnudayun.coding.me/Blog建设/</id>
    <published>2018-04-22T12:20:00.000Z</published>
    <updated>2018-04-22T15:53:12.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="blog大致完工"><a href="#blog大致完工" class="headerlink" title="blog大致完工"></a>blog大致完工</h1><p>各种操作尚未熟练，blog的外观问题改日再弄，先学一波操作，每日更新（假装日更）<br>貌似这玩意被我当日记本了？还是笔记本？<br>也 不 care</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;blog大致完工&quot;&gt;&lt;a href=&quot;#blog大致完工&quot; class=&quot;headerlink&quot; title=&quot;blog大致完工&quot;&gt;&lt;/a&gt;blog大致完工&lt;/h1&gt;&lt;p&gt;各种操作尚未熟练，blog的外观问题改日再弄，先学一波操作，每日更新（假装日更）&lt;br&gt;貌似
      
    
    </summary>
    
    
  </entry>
  
</feed>
